# Enhanced Unpacking Stub with ChaCha20 Decryption (Pure Assembly)\n.global _start\n.section .text\n.code64\n\n# Include our ChaCha20 core implementation\n.include \"chacha20_core.s\"\n\n_start:\n    # Get base address of the stub\n    lea (_start)(%rip), %r8\n    # Mask to page boundary (4KB pages)\n    and $~0xFFF, %r8\n    \n    # Write debug message\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    lea msg(%rip), %rsi # message\n    mov $msg_len, %rdx  # message length\n    syscall\n    \n    # Report base address\n    mov %r8, %rsi\n    call write_hex\n    \n    # Read and report OEP (8 bytes at offset 0x400)\n    mov 0x400(%r8), %r9\n    lea oep_msg(%rip), %rsi\n    mov $oep_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Key part 1 (8 bytes at offset 0x408)\n    mov 0x408(%r8), %r9\n    lea key1_msg(%rip), %rsi\n    mov $key1_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Key part 2 (8 bytes at offset 0x410)\n    mov 0x410(%r8), %r9\n    lea key2_msg(%rip), %rsi\n    mov $key2_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Key part 3 (8 bytes at offset 0x418)\n    mov 0x418(%r8), %r9\n    lea key3_msg(%rip), %rsi\n    mov $key3_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Key part 4 (8 bytes at offset 0x420)\n    mov 0x420(%r8), %r9\n    lea key4_msg(%rip), %rsi\n    mov $key4_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Nonce (12 bytes at offset 0x428)\n    mov 0x428(%r8), %r9\n    lea nonce_msg(%rip), %rsi\n    mov $nonce_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report CA Steps (4 bytes at offset 0x434)\n    mov 0x434(%r8), %r9\n    lea ca_steps_msg(%rip), %rsi\n    mov $ca_steps_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Payload Section RVA (4 bytes at offset 0x438)\n    mov 0x438(%r8), %r9\n    lea payload_rva_msg(%rip), %rsi\n    mov $payload_rva_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Read and report Payload Size (4 bytes at offset 0x43C)\n    mov 0x43C(%r8), %r9\n    lea payload_size_msg(%rip), %rsi\n    mov $payload_size_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Deobfuscate the key parts\n    # XOR each key part with the fixed key (0xCABEFEBEEFBEADDE)\n    mov $0xCABEFEBEEFBEADDE, %r10  # Fixed obfuscation key\n    \n    # Deobfuscate key part 1\n    mov 0x408(%r8), %r11\n    xor %r10, %r11\n    mov %r11, 0x408(%r8)  # Store deobfuscated key part 1 back\n    \n    # Deobfuscate key part 2\n    mov 0x410(%r8), %r11\n    xor %r10, %r11\n    mov %r11, 0x410(%r8)  # Store deobfuscated key part 2 back\n    \n    # Deobfuscate key part 3\n    mov 0x418(%r8), %r11\n    xor %r10, %r11\n    mov %r11, 0x418(%r8)  # Store deobfuscated key part 3 back\n    \n    # Deobfuscate key part 4\n    mov 0x420(%r8), %r11\n    xor %r10, %r11\n    mov %r11, 0x420(%r8)  # Store deobfuscated key part 4 back\n    \n    # Report deobfuscated key parts\n    lea deobfuscated_key_msg(%rip), %rsi\n    mov $deobfuscated_key_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    \n    # Report deobfuscated key part 1\n    mov 0x408(%r8), %r9\n    lea key1_msg(%rip), %rsi\n    mov $key1_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Report deobfuscated key part 2\n    mov 0x410(%r8), %r9\n    lea key2_msg(%rip), %rsi\n    mov $key2_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Report deobfuscated key part 3\n    mov 0x418(%r8), %r9\n    lea key3_msg(%rip), %rsi\n    mov $key3_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # Report deobfuscated key part 4\n    mov 0x420(%r8), %r9\n    lea key4_msg(%rip), %rsi\n    mov $key4_msg_len, %rdx\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    syscall\n    mov %r9, %rsi\n    call write_hex\n    \n    # For now, just exit with code 42\n    # In a real implementation, we would:\n    # 1. Allocate memory for the decrypted payload\n    # 2. Read the encrypted payload from the specified RVA\n    # 3. Decrypt the payload using the key and nonce\n    # 4. Apply CA unmasking to the decrypted payload\n    # 5. Jump to the OEP\n    \n    # Exit with code 42\n    mov $60, %rax       # sys_exit\n    mov $42, %rdi       # exit code\n    syscall\n\n# Function to write a hex value to stderr\nwrite_hex:\n    push %rbp\n    mov %rsp, %rbp\n    sub $32, %rsp       # Allocate space for buffer\n    \n    # Convert value in %rsi to hex string\n    mov %rsi, %rax      # Value to convert\n    lea -32(%rbp), %rdi # Buffer address\n    mov $16, %rcx       # 16 characters for 64-bit value\n    \nconvert_loop:\n    rol $4, %rax        # Rotate left by 4 bits\n    mov %rax, %r9\n    and $0xF, %r9       # Get low 4 bits\n    cmp $9, %r9\n    jle numeric\n    add $7, %r9         # Adjust for A-F\nnumeric:\n    add $48, %r9        # Convert to ASCII\n    mov %r9b, (%rdi)    # Store character\n    inc %rdi\n    loop convert_loop\n    \n    # Write \"0x\" prefix\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    lea prefix(%rip), %rsi # \"0x\" prefix\n    mov $2, %rdx        # 2 characters\n    syscall\n    \n    # Write hex value\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    lea -32(%rbp), %rsi # Buffer address\n    mov $16, %rdx       # 16 characters\n    syscall\n    \n    # Write newline\n    mov $1, %rax        # sys_write\n    mov $2, %rdi        # stderr fd\n    lea newline(%rip), %rsi # newline\n    mov $1, %rdx        # 1 character\n    syscall\n    \n    leave\n    ret\n\n# Function to allocate memory using mmap\n# Parameters:\n#   %rdi - size of memory to allocate\n# Returns:\n#   %rax - pointer to allocated memory (or -1 on error)\nallocate_memory:\n    push %rbp\n    mov %rsp, %rbp\n    \n    # Save registers\n    push %rdi\n    push %rsi\n    push %rdx\n    push %r10\n    push %r8\n    push %r9\n    \n    # mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)\n    # addr = NULL (0)\n    # length = size (passed in %rdi)\n    # prot = PROT_READ | PROT_WRITE (0x3)\n    # flags = MAP_PRIVATE | MAP_ANONYMOUS (0x22)\n    # fd = -1\n    # offset = 0\n    \n    mov %rdi, %rsi          # length\n    mov $0, %rdi            # addr = NULL\n    mov $0x3, %rdx          # prot = PROT_READ | PROT_WRITE\n    mov $0x22, %r10         # flags = MAP_PRIVATE | MAP_ANONYMOUS\n    mov $-1, %r8            # fd = -1\n    mov $0, %r9             # offset = 0\n    mov $9, %rax            # sys_mmap\n    syscall\n    \n    # Restore registers\n    pop %r9\n    pop %r8\n    pop %r10\n    pop %rdx\n    pop %rsi\n    pop %rdi\n    \n    leave\n    ret\n\n# Function to deallocate memory using munmap\n# Parameters:\n#   %rdi - pointer to memory to deallocate\n#   %rsi - size of memory to deallocate\n# Returns:\n#   %rax - 0 on success, -1 on error\nd eallocate_memory:\n    push %rbp\n    mov %rsp, %rbp\n    \n    # Save registers\n    push %rdi\n    push %rsi\n    push %rdx\n    \n    # munmap(void *addr, size_t length)\n    mov %rdi, %rdi          # addr (passed in %rdi)\n    mov %rsi, %rsi          # length (passed in %rsi)\n    mov $11, %rax           # sys_munmap\n    syscall\n    \n    # Restore registers\n    pop %rdx\n    pop %rsi\n    pop %rdi\n    \n    leave\n    ret\n\n# Function to decrypt data using ChaCha20-Poly1305\n# Parameters:\n#   %rdi - pointer to ciphertext\n#   %rsi - size of ciphertext\n#   %rdx - pointer to key (32 bytes)\n#   %rcx - pointer to nonce (12 bytes)\n#   %r8 - pointer to output buffer\n# Returns:\n#   %rax - size of decrypted data (or -1 on error)\ndecrypt_chacha20_poly1305:\n    push %rbp\n    mov %rsp, %rbp\n    \n    # Save registers\n    push %rdi\n    push %rsi\n    push %rdx\n    push %rcx\n    push %r8\n    push %r9\n    push %r10\n    push %r11\n    \n    # For now, just return an error since we haven't implemented the full ChaCha20-Poly1305\n    # In a real implementation, we would:\n    # 1. Validate parameters\n    # 2. Extract the authentication tag from the end of the ciphertext\n    # 3. Verify the authentication tag\n    # 4. Decrypt the ciphertext using ChaCha20\n    # 5. Return the size of the decrypted data\n    \n    mov $-1, %rax  # Return error for now\n    \n    # Restore registers\n    pop %r11\n    pop %r10\n    pop %r9\n    pop %r8\n    pop %rcx\n    pop %rdx\n    pop %rsi\n    pop %rdi\n    \n    leave\n    ret\n\n# Function to apply CA unmasking\n# Parameters:\n#   %rdi - pointer to data\n#   %rsi - size of data\n#   %rdx - pointer to key material (32 bytes)\n#   %rcx - block index\n# Returns:\n#   %rax - 0 on success, -1 on error\napply_ca_unmasking:\n    push %rbp\n    mov %rsp, %rbp\n    \n    # Save registers\n    push %rdi\n    push %rsi\n    push %rdx\n    push %rcx\n    push %r8\n    push %r9\n    push %r10\n    push %r11\n    \n    # For now, just return success since we haven't implemented the full CA unmasking\n    # In a real implementation, we would:\n    # 1. Validate parameters\n    # 2. Generate mask using CA (Rule 30)\n    # 3. XOR the data with the mask\n    # 4. Return success\n    \n    mov $0, %rax  # Return success for now\n    \n    # Restore registers\n    pop %r11\n    pop %r10\n    pop %r9\n    pop %r8\n    pop %rcx\n    pop %rdx\n    pop %rsi\n    pop %rdi\n    \n    leave\n    ret\n\n.section .data\nmsg:\n    .ascii \"CA-Packer Enhanced Unpacking Stub with ChaCha20 Executing\\nBase address: \"\nmsg_len = . - msg\nprefix:\n    .ascii \"0x\"\nnewline:\n    .ascii \"\\n\"\noep_msg:\n    .ascii \"OEP: \"\noep_msg_len = . - oep_msg\nkey1_msg:\n    .ascii \"Key Part 1: \"\nkey1_msg_len = . - key1_msg\nkey2_msg:\n    .ascii \"Key Part 2: \"\nkey2_msg_len = . - key2_msg\nkey3_msg:\n    .ascii \"Key Part 3: \"\nkey3_msg_len = . - key3_msg\nkey4_msg:\n    .ascii \"Key Part 4: \"\nkey4_msg_len = . - key4_msg\nnonce_msg:\n    .ascii \"Nonce: \"\nnonce_msg_len = . - nonce_msg\nca_steps_msg:\n    .ascii \"CA Steps: \"\nca_steps_msg_len = . - ca_steps_msg\npayload_rva_msg:\n    .ascii \"Payload RVA: \"\npayload_rva_msg_len = . - payload_rva_msg\npayload_size_msg:\n    .ascii \"Payload Size: \"\npayload_size_msg_len = . - payload_size_msg\ndeobfuscated_key_msg:\n    .ascii \"Deobfuscated Key Parts:\\n\"\ndeobfuscated_key_msg_len = . - deobfuscated_key_msg\n