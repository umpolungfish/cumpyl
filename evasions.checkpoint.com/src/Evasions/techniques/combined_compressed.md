::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: CPU {#evasions-cpu .post-title-main itemprop="name headline"}\n=============\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[CPU detection methods used](#cpu-detection-methods)\\n[1. Check vendor ID string via CPUID\ninstruction](#check-vendor-id-via-cpuid)\\n[2. Check if being run in Hypervisor via CPUID\ninstruction](#check-if-being-run-in-Hypervisor-via-cpuid)\\n[3. Check for global tables location:\nIDT/GDT/LDT](#check-for-global-tables-location)\\n[4. Using exotic instructions to fool virtual\nemulators](#using-exotic-instructions-to-fool-virtual-emulators)\\n[5. Detecting environment via execution of illegal instructions\n(VirtualPC\nonly)](#detecting-environment-via-illegal-instructions-virtualpc)\\n[6. Detecting environment via IN instruction - backdoor port (VMware\nonly)](#detecting-environment-via-in-backdoor-port-vmware)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures-sandboxie)\\n[Credits](#credits)\\n\\n\n\n[CPU detection methods used]{#cpu-detection-methods .a-dummy}\n-------------------------------------------------------------\n\nTechniques in this group use specific processor instructions to either\nget particular information about CPU --- or execute predefined\ninstruction sequence which behaves differently in usual host OS and in\nvirtual environment.\n\n\\n\n### [1. Check vendor ID string via CPUID instruction]{#check-vendor-id-via-cpuid .a-dummy}\n\nThe [CPUID](https://x86.renejeschke.de/html/file_module_x86_id_45.html)\ninstruction is an instruction that returns processor identification and\nfeature information to `EBX, ECX, EDX`. The information received to\nthese registers can be used to identify a vendor.\n\n\n**Code sample**\n\n    __declspec(naked) void get_cpuid_vendor(char *vendor_id) {\n      __asm {        \n        ; save non-volatile register\n        push ebx\n        \n        ; nullify output registers\n        xor ebx, ebx\n        xor ecx, ecx\n        xor edx, edx\n        \n        ; call cpuid with argument in EAX\n        mov eax, 0x40000000\n        cpuid\n        \n        ; store vendor_id ptr to destination\n        mov edi, vendor_id\n        \n        ; move string parts to destination\n        mov eax, ebx  ; part 1 of 3 from EBX\n        stosd\n        mov eax, ecx  ; part 2 of 3 from ECX\n        stosd\n        mov eax, edx  ; part 3 of 3 from EDX\n        stosd\n        \n        ; restore saved non-volatile register\n        pop ebx \n        \n        ; return from function\n        retn\n      }\n    }\n\n\n**Detections table**\n\nCheck vendor ID string via CPUID instruction - returned in parts in EBX,\nECX, EDX:\n:::\n:::\n\nDetect\n\nEAX as argument to CPUID\n\nString\n\nFreeBSD HV\n\n0x40000000\n\nbhyve bhyve\n\nHyper-V\n\n0x40000000\n\nMicrosoft Hv\n\nKVM\n\n0x40000000\n\nKVMKVMKVM\n\nParallels\n\n0x40000000\n\nprl hyperv\n\nVirtualBox\n\n0x40000000\n\nVBoxVBoxVBox\n\nVirtualPC\n\n0x40000000\n\nMicrosoft Hv\n\nVMware\n\n0x40000000\n\nVMwareVMware\n\nXen\n\n0x40000000\n\nXenVMMXenVMM\n\n\\n\n### [2. Check if being run in Hypervisor via CPUID instruction]{#check-if-being-run-in-Hypervisor-via-cpuid .a-dummy}\n\nAn other way to detect if the program is being run in hypervisor is\nusing the `CPUID` instruction in an other way.\\n\\nInstead of setting `EAX` (the argument to `CPUID`) to be `0x40000000`,\n`EAX` is set to 1.\\n\\nWhen `EAX` is set to 1, the 31st bit in `ECX` (`CPUID`'s returned value)\nis set, it indicates that the program is being run in Hypervisor.\n\n\n**Code sample (function `GetAdaptersAddresses`)**\n\n    __declspec(naked) bool is_run_in_hypervisor() {\n      __asm {\n        ; nullify output register\n        xor ecx, ecx\n        \n        ; call cpuid with argument in EAX\n        mov eax, 1\n        cpuid\n        \n        ; set CF equal to 31st bit in ECX\n        bt ecx, 31\n        \n        ; set AL to the value of CF\n        setc al\n        \n        ; return from function\n        retn\n      }\n    }\n\n\n**Detections table**\n\nCheck if being run in Hypervisor (via CPUID)\n\nDetect\n\nEAX as argument to CPUID\n\nCheck of return value\n\nHypervisor\n\n1\n\n31st bit in ECX - set if run in Hypervisor\n\n\\n\n### [3. Check for global tables location: IDT/GDT/LDT]{#check-for-global-tables-location .a-dummy}\n\n*This technique doesn't work on latest VMware releases (all Windows\nreleases affected). However, it is described here for the sake of\ncompleteness.*\\n\\n\nThis trick involves looking at the pointers to critical operating system\ntables that are typically relocated on a virtual machine. It's what\ncalled "Red Pill" and was [first\nintroduced](http://web.archive.org/web/20070325211649/http://www.invisiblethings.org/papers/redpill.html)\nby Joanna Rutkowska.\\n\\nThere is one Local Descriptor Table Register (LDTR), one Global\nDescriptor Table Register (GDTR), and one Interrupt Descriptor Table\nRegister (IDTR) per CPU. They have to be moved to a different location\nwhen a guest operating system is running to avoid conflicts with the\nhost.\\n\\nOn real machines the IDT, for example, is located lower in memory than\nit is on guest (i.e., virtual) machines.\\n\n\n**Code sample**\n\n    idt_vm_detect = ((get_idt_base() >> 24) == 0xff);\n    ldt_vm_detect = (get_ldt_base() == 0xdead0000);\n    gdt_vm_detect = ((get_gdt_base >> 24) == 0xff);\n\n    // sidt instruction stores the contents of the IDT Register \n    // (the IDTR which points to the IDT) in a processor register.\n    ULONG get_idt_base() {    \n        UCHAR idtr[6];\n    #if defined (ENV32BIT)\n        _asm sidt idtr\n    #endif\n        return *((unsigned long *)&idtr[2]);\n    }\n\n    // sldt instruction stores the contents of the LDT Register \n    // (the LDTR which points to the LDT) in a processor register.\n    ULONG get_ldt_base() {\n        UCHAR ldtr[5] = "\xef\xbe\xad\xde";\n    #if defined (ENV32BIT)\n        _asm sldt ldtr\n    #endif\n        return *((unsigned long *)&ldtr[0]);\n    }\n\n    // sgdt instruction stores the contents of the GDT Register \n    // (the GDTR which points to the GDT) in a processor register.\n    ULONG get_gdt_base() {\n        UCHAR gdtr[6];\n    #if defined (ENV32BIT)\n        _asm sgdt gdtr\n    #endif\n        return gdt = *((unsigned long *)&gdtr[2]);\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\\n\n### [4. Using exotic instructions to fool virtual emulators]{#using-exotic-instructions-to-fool-virtual-emulators .a-dummy}\n\nThis technique is described [by this\nlink](https://www.slideshare.net/Cyphort/mmw-antisandbox-techniques)\n(slide \#37).\\n\\nMMX instructions may be used as random instructions by malware.\nSometimes such subsets of CPU instruction are not supported by emulators\nand thus exception is thrown instead of performing analysis.\n\n\n**Example:**\n\n::: {style="text-align: center"}\n![](../assets/images/mmx_anti_sb.png)\n:::\n\n\\n\n### [5. Detecting environment via execution of illegal instructions (VirtualPC only)]{#detecting-environment-via-illegal-instructions-virtualpc .a-dummy}\n\nThe malware executes illegal instructions, which should generate\nexception on the real CPU but are executed normally - or in some\ndifferent way - in virtual environment.\\n\\nInformation about CPU exceptions is provided [by this\nlink](https://wiki.osdev.org/Exceptions#Invalid_Opcode).\n\n\n**Code sample (variant 1, generating \#ud exception)**\n\n    push ebx\n    xor ebx, ebx\n    mov eax, 1\n    ; the following 4 bytes below generate #ud exception\n    db 0x0F\n    db 0x3F\n    db 0x0D\n    db 0x00\n    test ebx, ebx\n    setz al\n    pop ebx\n\n\nIt should be emphasized that there are more than 1,000 combinations of\n\n    0x0F\n    0x3F\n    0xXX\n    0xYY\n\nbytes that may be used by malware in order to detect VirtualPC\nenviroment.\n\n\n**Code sample (variant 2, executing illegal STI instruction)**\n\n    // Taken here: https://pastebin.com/Nsv5B1yk\n    // http://waleedassar.blogspot.com\n    // http://www.twitter.com/waleedassar\n    // Use this code to detect if Windows XP is running inside Virtual PC 2007\n    #include "stdafx.h"\n    #include "windows.h"\n    #include "stdio.h"\n     \n    #define CONTEXT_ALL 0x1003F\n     \n    int dummy(int);\n    unsigned long gf=0;\n\n    int __cdecl Handler(EXCEPTION_RECORD* pRec,void* est,unsigned char* pContext,void* disp)\n    {\n        if(pRec->ExceptionCode==0xC0000096)  //Privileged instruction\n        {\n            //---------------------Installing the trick--------------------------------------\n            *(unsigned long*)(pContext)=CONTEXT_ALL;/*CONTEXT_DEBUG_REGISTERS|CONTEXT_FULL*/\n            *(unsigned long*)(pContext+0x4)=(unsigned long)(&dummy);\n            *(unsigned long*)(pContext+0x8)=(unsigned long)(&dummy);\n            *(unsigned long*)(pContext+0xC)=(unsigned long)(&dummy);\n            *(unsigned long*)(pContext+0x10)=(unsigned long)(&dummy);\n            *(unsigned long*)(pContext+0x14)=0;\n            *(unsigned long*)(pContext+0x18)=0x155; //Enable the four DRx On-Execute\n            (*(unsigned long*)(pContext+0xB8))++;\n            return ExceptionContinueExecution;\n        }\n        else if(pRec->ExceptionCode==EXCEPTION_SINGLE_STEP)\n        {\n            if(gf==1)\n            {\n                MessageBox(0,"Expected behavior (XP)","waliedassar",0);\n                ExitProcess(0);\n            }\n            gf++;\n            (*(unsigned long*)(pContext+0xC0))|=0x00010000; //Set the RF (Resume Flag)\n            return ExceptionContinueExecution;\n        }\n        return ExceptionContinueSearch;\n    }\n     \n    int dummy(int x)\n    {\n        x+=0x100;\n        return x;\n    }\n     \n    int main(int shitArg)\n    {\n        unsigned long ver_=GetVersion();\n        unsigned long major=ver_&0xFF;\n        unsigned long minor=(ver_>>0x8)&0xFF;\n        if(major==0x05 & minor==0x01) //Windows XP\n        {\n            unsigned long x=0;\n            __asm\n            {\n                push offset Handler\n                push dword ptr fs:[0x0]\n                mov dword ptr fs:[0x0],esp\n                STI; Triggers an exception(privileged instruction)\n            }\n            dummy(0xFF);\n            __asm\n            {\n                pop dword ptr fs:[0x0]\n                pop ebx\n            }\n            MessageBox(0,"Virtual PC 2007 detected (XP)","waliedassar",0);\n        }\n        return 0;\n    }\n\n\n**Code sample (variant 3, resetting VirtualPC)**\n\n    // Taken here: https://pastebin.com/exAK5XQx\n    // http://waleedassar.blogspot.com (@waleedassar)\n    // Executing "\x0F\xC7\xC8\x05\x00" in VirtualPC 2007 triggers a reset error.\n    #include "stdafx.h"\n    #include "windows.h"\n    #include "stdio.h"\n     \n    bool flag=false;\n     \n    int __cdecl Handler(EXCEPTION_RECORD* pRec,void* est,unsigned char* pContext,void* disp)\n    {\n        if(pRec->ExceptionCode==0xC000001D  || pRec->ExceptionCode==0xC000001E || pRec->ExceptionCode==0xC0000005)\n        {\n            flag=true;\n            (*(unsigned long*)(pContext+0xB8))+=5;\n            return ExceptionContinueExecution;\n        }\n        return ExceptionContinueSearch;\n    }\n     \n    int main(int argc, char* argv[])\n    {\n        __asm\n        {\n            push offset Handler\n            push dword ptr fs:[0x0]\n            mov dword ptr fs:[0x0],esp\n        }\n        flag=false;\n        __asm\n        {\n            __emit 0x0F\n            __emit 0xC7\n            __emit 0xC8\n            __emit 0x05\n            __emit 0x00\n        }\n        if(flag==false)\n        {\n            MessageBox(0,"VirtualPC detected","waliedassar",0);\n        }\n        __asm\n        {\n            pop dword ptr fs:[0x0]\n            pop eax\n        }\n        return 0;\n    }\n\n\\n\n### [6. Detecting environment via IN instruction - backdoor port (VMware only)]{#detecting-environment-via-in-backdoor-port-vmware .a-dummy}\n\n[This article](https://sites.google.com/site/chitchatvmback/backdoor)\nexplains why backdoor port communication is used in VMware in the first\nplace.\n\n\n**Code sample (variant 1)**\n\n    bool VMWare::CheckHypervisorPort() const {\n        bool is_vm = false;\n        __try {\n            __asm {\n                push edx\n                push ecx\n                push ebx\n                mov eax, 'VMXh'\n                mov ebx, 0\n                mov ecx, 10\n                mov edx, 'VX'\n                in eax, dx      // <- key point is here\n                cmp ebx, 'VMXh'\n                setz[is_vm]\n                pop ebx\n                pop ecx\n                pop edx\n            }\n        } \n        __except (EXCEPTION_EXECUTE_HANDLER) {\n            is_vm = false;\n        }\n        return is_vm;\n    }\n\n\n**Code sample (variant 2)**\n\n    bool VMWare::CheckHypervisorPortEnum() const {\n        bool is_vm = false;\n        short ioports[] = { 'VX' , 'VY' };\n        short ioport;\n        for (short i = 0; i < _countof(ioports); ++i) {\n            ioport = ioports[i];\n            for (unsigned char cmd = 0; cmd < 0x2c; ++cmd) {\n                __try {\n                    __asm {\n                        push eax\n                        push ebx\n                        push ecx\n                        push edx\n                        mov eax, 'VMXh'\n                        movzx ecx, cmd\n                        mov dx, ioport\n                        in eax, dx      // <- key point is here\n                        pop edx\n                        pop ecx\n                        pop ebx\n                        pop eax\n                    }\n                    is_vm = true;\n                    break;\n                }\n                __except (EXCEPTION_EXECUTE_HANDLER) {}\n            }\n            if (is_vm)\n                break;\n        }\n        return is_vm;\n    }\n\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*No signature recommendations are provided for this evasion group as\nit's hard to track such a code being executed.*\n\n\\n\n### [Countermeasures]{#countermeasures-sandboxie .a-dummy}\n\nPatch hypervisor. If it proves impossible --- due to license issues or\nsomething else --- patch VM config. Usually undocumented options help.\n\n-   vs `CPUID` instruction: refer to [this\n    article](http://vknowledge.net/2014/04/17/how-to-fake-a-vms-guest-os-cpuid/)\n    for the example of such a patch\n-   vs `IN` instruction (VMware backdoor): take a look at these [config\n    changes](https://wasm.in/threads/izmenenie-raboty-backdoor-interfejsa-v-vmware.24564/#post-291532)\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken and\nto independent researcher who shared his findings:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n-   [\@waleedassar](https://twitter.com/waleedassar)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Filesystem {#evasions-filesystem .post-title-main itemprop="name headline"}\n====================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Filesystem detection methods](#filesystem-detection-methods)\\n[1. Check if specific files exist](#check-if-specific-files-exist)\\n[2. Check if specific directories are\npresent](#check-if-specific-directories-present)\\n[3. Check if full path to the executable contains one of specific\nstrings](#check-if-full-path-exec)\\n[4. Check if the executable is run from specific\ndirectory](#check-if-exec-is-run)\\n[5. Check if the executable files with specific names are present in\nphysical disk drives root](#check-if-exec-files-with-specific-names)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n[Filesystem detection methods]{#filesystem-detection-methods .a-dummy}\n----------------------------------------------------------------------\n\nThe principle of all the filesystem detection methods is the following:\nthere are no such files and directories in usual host; however they\nexist in particular virtual environments and sandboxes. Virtual\nenvironment may be detected if such an artifact is present.\n\n\\n\n### [1. Check if specific files exist]{#check-if-specific-files-exist .a-dummy}\n\nThis method uses the difference in files which are present in usual host\nsystem and virtual environments. There are quite a few file artifacts\npresent in virtual environments which are specific for such kinds of\nsystems. These files are not present on usual host systems where no\nvirtual environment is installed.\n\nFunction used:\n\n-   `GetFileAttributes  // if attributes are invalid then no file exists`\n\n\n**Code sample**\n\n    BOOL is_FileExists(TCHAR* szPath)\n    {\n        DWORD dwAttrib = GetFileAttributes(szPath);\n        return (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);\n    }\n\n    /*\n    Check against some of VMware blacklisted files\n    */\n    VOID vmware_files()\n    {\n        /* Array of strings of blacklisted paths */\n        TCHAR* szPaths[] = {\n            _T("system32\\drivers\\vmmouse.sys"),\n            _T("system32\\drivers\\vmhgfs.sys"),\n        };\n        \n        /* Getting Windows Directory */\n        WORD dwlength = sizeof(szPaths) / sizeof(szPaths[0]);\n        TCHAR szWinDir[MAX_PATH] = _T("");\n        TCHAR szPath[MAX_PATH] = _T("");\n        GetWindowsDirectory(szWinDir, MAX_PATH);\n        \n        /* Check one by one */\n        for (int i = 0; i < dwlength; i++)\n        {\n            PathCombine(szPath, szWinDir, szPaths[i]);\n            TCHAR msg[256] = _T("");\n            _stprintf_s(msg, sizeof(msg) / sizeof(TCHAR), _T("Checking file %s: "), szPath);\n            if (is_FileExists(szPath))\n                print_results(TRUE, msg);\n            else\n                print_results(FALSE, msg);\n        }\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Signature recommendations**\n\nIf the following function contains its only argument from the table\ncolumn \`Path\`:\n\n-   `GetFileAttributes(path)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following files exist:\n:::\n:::\n\nDetect\n\nPath\n\nDetails (if any)\n\n\[general\]\n\nc:\\\[60 random hex symbols\]\n\nfile unique to the PC used for encoding\n\nc:\\take\_screenshot.ps1\n\nc:\\loaddll.exe\n\nc:\\email.doc\n\nc:\\email.htm\n\nc:\\123\\email.doc\n\nc:\\123\\email.docx\n\nc:\\a\\foobar.bmp\n\nc:\\a\\foobar.doc\n\nc:\\a\\foobar.gif\n\nc:\\symbols\\aagmmc.pdb\n\nParallels\n\nc:\\windows\\system32\\drivers\\prleth.sys\n\nNetwork Adapter\n\nc:\\windows\\system32\\drivers\\prlfs.sys\n\nc:\\windows\\system32\\drivers\\prlmouse.sys\n\nMouse Synchronization Tool\n\nc:\\windows\\system32\\drivers\\prlvideo.sys\n\nc:\\windows\\system32\\drivers\\prltime.sys\n\nTime Synchronization Driver\n\nc:\\windows\\system32\\drivers\\prl\_pv32.sys\n\nParavirtualization Driver\n\nc:\\windows\\system32\\drivers\\prl\_paravirt\_32.sys\n\nParavirtualization Driver\n\nVirtualBox\n\nc:\\windows\\system32\\drivers\\VBoxMouse.sys\n\nc:\\windows\\system32\\drivers\\VBoxGuest.sys\n\nc:\\windows\\system32\\drivers\\VBoxSF.sys\n\nc:\\windows\\system32\\drivers\\VBoxVideo.sys\n\nc:\\windows\\system32\\vboxdisp.dll\n\nc:\\windows\\system32\\vboxhook.dll\n\nc:\\windows\\system32\\vboxmrxnp.dll\n\nc:\\windows\\system32\\vboxogl.dll\n\nc:\\windows\\system32\\vboxoglarrayspu.dll\n\nc:\\windows\\system32\\vboxoglcrutil.dll\n\nc:\\windows\\system32\\vboxoglerrorspu.dll\n\nc:\\windows\\system32\\vboxoglfeedbackspu.dll\n\nc:\\windows\\system32\\vboxoglpackspu.dll\n\nc:\\windows\\system32\\vboxoglpassthroughspu.dll\n\nc:\\windows\\system32\\vboxservice.exe\n\nc:\\windows\\system32\\vboxtray.exe\n\nc:\\windows\\system32\\VBoxControl.exe\n\nVirtualPC\n\nc:\\windows\\system32\\drivers\\vmsrvc.sys\n\nc:\\windows\\system32\\drivers\\vpc-s3.sys\n\nVMware\n\nc:\\windows\\system32\\drivers\\vmmouse.sys\n\nPointing PS/2 Device Driver\n\nc:\\windows\\system32\\drivers\\vmnet.sys\n\nc:\\windows\\system32\\drivers\\vmxnet.sys\n\nPCI Ethernet Adapter\n\nc:\\windows\\system32\\drivers\\vmhgfs.sys\n\nHGFS Filesystem Driver\n\nc:\\windows\\system32\\drivers\\vmx86.sys\n\nc:\\windows\\system32\\drivers\\hgfs.sys\n\n\\n\n### [2. Check if specific directories are present]{#check-if-specific-directories-present .a-dummy}\n\nThis method uses the difference in directories which are present in\nusual host system and virtual environments. There are quite a few\ndirectory artifacts present in virtual environments which are specific\nfor such kinds of systems. These directories are not present on usual\nhost systems where no virtual environment is installed.\n\nFunction used:\n\n-   `GetFileAttributes  // if attributes are invalid then no file exists`\n\n\n**Code sample**\n\n    BOOL is_DirectoryExists(TCHAR* szPath)\n    {\n        DWORD dwAttrib = GetFileAttributes(szPath);\n        return (dwAttrib != INVALID_FILE_ATTRIBUTES) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY);\n    }\n\n    /*\n    Check against VMware blacklisted directory\n    */\n    BOOL vmware_dir()\n    {\n        TCHAR szProgramFile[MAX_PATH];\n        TCHAR szPath[MAX_PATH] = _T("");\n        TCHAR szTarget[MAX_PATH] = _T("VMware\\");\n        if (IsWoW64())\n            ExpandEnvironmentStrings(_T("%ProgramW6432%"), szProgramFile, ARRAYSIZE(szProgramFile));\n        else\n            SHGetSpecialFolderPath(NULL, szProgramFile, CSIDL_PROGRAM_FILES, FALSE);\n        PathCombine(szPath, szProgramFile, szTarget);\n        return is_DirectoryExists(szPath);\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Signature recommendations**\n\nIf the following function contains its only argument from the table\ncolumn \`Path\`:\n\n-   `GetFileAttributes(path)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following files exist:\n\nDetect\n\nPath\n\nCWSandbox\n\nc:\\analysis\n\nVirtualBox\n\n%PROGRAMFILES%\\oracle\\virtualbox guest additions\\\n\nVMware\n\n%PROGRAMFILES%\\VMware\\\n\n\\n\n### [3. Check if full path to the executable contains one of the specific strings]{#check-if-full-path-exec .a-dummy}\n\nThis method relies on peculiarities of launching executables inside\nvirtual environments. Some environments launch executables from specific\npaths - and malware samples check these paths.\n\nFunctions used to get executable path:\n\n-   `GetModuleFileName`\n-   `GetProcessImageFileNameA/W`\n-   `QueryFullProcessImageName`\n\n\n**Code sample (function GetModuleFileName)**\n\n    int gensandbox_path() {\n        char path[500];\n        size_t i;\n        DWORD pathsize = sizeof(path);\n\n        GetModuleFileName(NULL, path, pathsize);\n\n        for (i = 0; i < strlen(path); i++) { /* case-insensitive */\n            path[i] = toupper(path[i]);\n        }\n\n        // some sample values from the table\n        if (strstr(path, "\\SAMPLE") != NULL) {\n            return TRUE;\n        }\n        if (strstr(path, "\\VIRUS") != NULL) {\n            return TRUE;\n        }\n        if (strstr(path, "SANDBOX") != NULL) {\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Code sample (function QueryFullProcessImageName)**\n\n    DWORD PID = 1337; // process ID of the target process\n    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, PID);\n    DWORD value = MAX_PATH;\n    char buffer[MAX_PATH];\n    QueryFullProcessImageName(hProcess, 0, buffer, &value);\n    printf("EXE Path: %s\n", buffer);\n\n\n**No signature recommendations**\n\nSignature recommendations are not provided as it's hard to say why\nexactly application wants to get its full path. Function calls may be\nhooked - and that's it, just general recommendation.\n\n\n**Detections table**\n\nCheck if full path to the executable contains one of the following\nstrings:\n\nDetect\n\nString\n\n\[general\]\n\n\\sample\n\n\\virus\n\nsandbox\n\n\\n\n### [4. Check if the executable is run from specific directory]{#check-if-exec-is-run .a-dummy}\n\nThis method relies on peculiarities of launching executables inside\nvirtual environments. Some environments launch executables from specific\ndirectories - and malware samples check these directories.\n\nIt's just a particular case of checking presence of specific strings in\nfull application path, please refer to the [section\nabove](#check-if-full-path-exec) for code sample and signature\nrecommendations.\n\nAs this very method is pretty old and is not commonly used, the links to\nexternal sources are provided for the reference on this method:\n\n-   VB [code sample](https://www.opensc.io/showthread.php?t=2343)\n-   python [code\n    sample](https://github.com/brad-accuvant/community-modified/blob/master/modules/signatures/antisandbox_joe_anubis_files.py)\n-   anti-emulation\n    [tricks](http://web.archive.org/web/20181222042516/www.woodmann.com/forum/showthread.php?12545-Anti-Emulation-Tricks)\n-   stub for [C\n    code](http://web.archive.org/web/20101026233743/http://evilcry.netsons.org/OC0/code/EmulationAwareness.c)\n\n\n**Detections table**\n\nCheck if the executable is run from the following directories:\n\nDetect\n\nPath\n\nAnubis\n\nc:\\insidetm\n\n\\n\n### [5. Check if the executable files with specific names are present in physical disk drives\' root]{#check-if-exec-files-with-specific-names .a-dummy}\n\nThis method relies on peculiarities of virtual environments, in this\ncase it's presence of specific files in disk root root directories.\n\nFunction used:\n\n-   `GetFileAttributes  // if attributes are invalid then no file exists`\n\n\n**Code sample (function GetModuleFileName)**\n\n    int pafish_exists_file(char * filename) {\n        DWORD res = INVALID_FILE_ATTRIBUTES;\n        if (pafish_iswow64() == TRUE) {\n            void *old = NULL;\n            // Disable redirection immediately prior to calling GetFileAttributes.\n            if (pafish_disable_wow64_fs_redirection(&old) ) {\n                res = GetFileAttributes(filename);\n                // Ignoring MSDN recommendation of exiting if this call fails.\n                pafish_revert_wow64_fs_redirection(old);\n            }\n        }\n        else {\n            res = GetFileAttributes(filename);\n        }\n        return (res != INVALID_FILE_ATTRIBUTES) ? TRUE : FALSE;\n    }\n\n    int gensandbox_common_names() {\n        DWORD dwSize = MAX_PATH;\n        char szLogicalDrives[MAX_PATH] = {0};\n        DWORD dwResult = GetLogicalDriveStrings(dwSize,szLogicalDrives);\n        BOOL exists;\n\n        if (dwResult > 0 && dwResult <= MAX_PATH)\n        {\n            char* szSingleDrive = szLogicalDrives;\n            char filename[MAX_PATH] = {0};\n            while(*szSingleDrive)\n            {\n                if (GetDriveType(szSingleDrive) != DRIVE_REMOVABLE ) {\n                    snprintf(filename, MAX_PATH, "%ssample.exe",szSingleDrive);\n                    exists = pafish_exists_file(filename);\n                    if (exists) return TRUE;\n                    \n                    snprintf(filename, MAX_PATH, "%smalware.exe",szSingleDrive);\n                    exists = pafish_exists_file(filename);\n                    if (exists) return TRUE;\n                }\n\n                szSingleDrive += strlen(szSingleDrive) + 1;\n            }\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Signature recommendations**\n\nIf the following function contains its only argument from the table\ncolumn \`Path\`:\n\n-   `GetFileAttributes(path)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the executables with particular names are present in disk root:\n\nDetect\n\nPath\n\n\[general\]\n\nmalware.exe\n\nsample.exe\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nHook target functions and return appropriate results if indicators\n(files from tables) are checked.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source projects from where code samples were taken:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n-   pafish project on [github](https://github.com/a0rtega/pafish)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Firmware tables {#evasions-firmware-tables .post-title-main itemprop="name headline"}\n=========================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Firmware tables detection methods](#firmware-tables-detection-methods)\\n[1. Check if specific strings are present in Raw Firmware\nTable](#check-specific-strings-in-raw-firmware-table)\\n[1.1. Windows\nVista+](#check-specific-strings-in-raw-firmware-table-vista)\\n[1.2. Windows XP](#check-specific-strings-in-raw-firmware-table-xp)\\n[2. Check if specific strings are present in Raw SMBIOS Firmware\nTable](#check-specific-strings-in-raw-smbios-firmware-table)\\n[2.1. Windows\nVista+](#check-specific-strings-in-raw-smbios-firmware-table-vista)\\n[2.2. Windows\nXP](#check-specific-strings-in-raw-smbios-firmware-table-xp)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[Firmware tables detection methods]{#firmware-tables-detection-methods .a-dummy}\n\nThere are special memory areas used by OS which contain specific\nartifacts if OS is run under virtual environment. These memory areas may\nbe dumped using different methods depending on the OS version.\n\n\nFirmware tables are retrieved via `SYSTEM_FIRMWARE_TABLE_INFORMATION`\nobject. It's defined the following way:\n\n    typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {\n        ULONG ProviderSignature;\n        SYSTEM_FIRMWARE_TABLE_ACTION Action;\n        ULONG TableID;\n        ULONG TableBufferLength;\n        UCHAR TableBuffer[ANYSIZE_ARRAY];  // <- the result will reside in this field\n    } SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;\n\n    // helper enum\n    typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION\n    {\n        SystemFirmwareTable_Enumerate,\n        SystemFirmwareTable_Get\n    } SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;\n\n\\n\n### [1. Check if specific strings are present in Raw Firmware Table]{#check-specific-strings-in-raw-firmware-table .a-dummy}\n\nRetrieved firmware table is scanned for the presence of particular\nstrings.\n\n\n*Depending on Windows version different functions are used for this\ncheck. See code samples below.*\n\n\\n\n#### [1.1. Windows Vista+]{#check-specific-strings-in-raw-firmware-table-vista .a-dummy}\n\n**Code sample**\n\n    // First, SYSTEM_FIRMWARE_TABLE_INFORMATION object is initialized in the following way:\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = \n        (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Length);\n    sfti->Action = SystemFirmwareTable_Get;  // 1\n    sfti->ProviderSignature = 'FIRM';\n    sfti->TableID = 0xC0000;\n    sfti->TableBufferLength = Length;\n\n    // Then initialized SYSTEM_FIRMWARE_TABLE_INFORMATION object is used as an argument for\n    // the system information call in the following way in order to dump raw firmware table:\n    NtQuerySystemInformation(\n        SystemFirmwareTableInformation,  // 76 \n        sfti,\n        Length,\n        &Length);\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Signature recommendations**\n\nIf the function\n\n-   `NtQuerySystemInformation`\n\ncontains:\n\n-   1st argument equal to 76 (SystemFirmwareTableInformation)\n-   2nd argument has `sfti->ProviderSignature` field initialized to\n    \'FIRM\' and `sfti->Action` field initialized to 1\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n\\n\n#### [1.2. Windows XP]{#check-specific-strings-in-raw-firmware-table-xp .a-dummy}\n\n**Code sample**\n\n    // In case if OS version is Vista+ csrss.exe memory space is read in order to dump raw firmware table:\n    hCSRSS = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, csrss_pid);\n\n    NtReadVirtualMemory( \n         hCSRSS, \n         0xC0000,\n         sfti, \n         RegionSize, \n         &memIO);\n\n\n**Signature recommendations**\n\nIf the following function contains PID of `csrss.exe` process as its 3rd\nargument:\n\n-   `HANDLE hCSRSS = OpenProcess(..., csrss_pid)`\n\nand is followed by the call to the following function:\n\n-   `NtReadVirtualMemory(hCSRSS, 0xC0000, ...)`\n\nwhich contains:\n\n-   1st argument equal to `csrss.exe` handle\n-   2nd argument equal to `0xC0000`\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n### Detections table\n\nCheck if the following strings are present in Raw Firmware Table:\n:::\n:::\n\nDetect\n\nString\n\nParallels\n\nParallels(R)\n\nVirtualBox\n\nInnotek\n\nOracle\n\nVirtualBox\n\nVirtualPC\n\nS3 Corp.\n\nVMware\n\nVMware\n\n\\n\n### [2. Check if specific strings are present in Raw SMBIOS Firmware Table]{#check-specific-strings-in-raw-smbios-firmware-table .a-dummy}\n\nRetrieved firmware table is scanned for the presence of particular\nstrings.\n\n\n*Depending on Windows version different functions are used for this\ncheck. See code samples below.*\n\n\\n\n#### [2.1. Windows Vista+]{#check-specific-strings-in-raw-smbios-firmware-table-vista .a-dummy}\n\n**Code sample**\n\n    // SYSTEM_FIRMWARE_TABLE_INFORMATION object is initialized in the following way:\n    SYSTEM_FIRMWARE_TABLE_INFORMATION *sfti = \n        (PSYSTEM_FIRMWARE_TABLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Length);\n    sfti->Action = SystemFirmwareTable_Get; // 1\n    sfti->ProviderSignature = 'RSMB';\n    sfti->TableID = 0;\n    sfti->TableBufferLength = Length;\n\n    // Then initialized SYSTEM_FIRMWARE_TABLE_INFORMATION object is used as an argument for\n    // the system information call in the following way in order to dump raw firmware table:\n    NtQuerySystemInformation(\n        SystemFirmwareTableInformation,  // 76 \n        sfti,\n        Length,\n        &Length);\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Signature recommendations**\n\nIf the following function:\n\n-   `NtQuerySystemInformation`\n\ncontains:\n\n-   1st argument equal to 76 (SystemFirmwareTableInformation)\n-   2nd argument has `sfti->ProviderSignature` field initialized to\n    \'RSMB\' and `sfti->Action` field initialized to 1\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n\\n\n#### [2.2. Windows XP]{#check-specific-strings-in-raw-smbios-firmware-table-xp .a-dummy}\n\n**Code sample**\n\n    // In case if OS version is Vista+ csrss.exe memory space is read in order to dump raw firmware table:\n    hCSRSS = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, csrss_pid);\n\n    NtReadVirtualMemory( \n         hCSRSS, \n         0xE0000,\n         sfti, \n         RegionSize, \n         &memIO);\n\n\n**Signature recommendations**\n\nIf the following function contains PID of `csrss.exe` process as its 3rd\nargument:\n\n-   `HANDLE hCSRSS = OpenProcess(..., csrss_pid)`\n\nand is followed by the call to the following function:\n\n-   `NtReadVirtualMemory(hCSRSS, 0xE0000, ...)`\n\nwhich contains:\n\n-   1st argument equal to `csrss.exe` handle\n-   2nd argument equal to `0xE0000`\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n### Detections table\n\nCheck if the following strings are present in Raw SMBIOS Firmware Table:\n\nDetect\n\nString\n\nParallels\n\nParallels Software International\n\nVirtualBox\n\nInnotek\n\nOracle\n\nVirtualBox\n\nVirtualPC\n\nVS2005R2\n\nVMware\n\nVMware, Inc.\n\nVMware\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\n-   On systems older than Vista change memory content of `csrss.exe` at\n    given addresses.\n-   On Vista+ OS hook `NtQuerySystemInformation` for retrieving\n    `SystemFirmwareTableInformation` class and parse `SFTI` structure\n    for provided field values.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   VMDE project on [github](https://github.com/hfiref0x/VMDE)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Generic OS queries {#evasions-generic-os-queries .post-title-main itemprop="name headline"}\n============================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Generic OS queries](#generic-os-queries)\\n[1. Check if the username is specific](#check-if-username-is-specific)\\n[2. Check if the computer name is\nspecific](#check-if-computer-name-is-specific)\\n[3. Check if the host name is\nspecific](#check-if-host-name-is-specific)\\n[4. Check if the total RAM is low](#check-if-total-ram-is-low)\\n[5. Check if the screen resolution is non-usual for host\nOS](#check-if-screen-res)\\n[6. Check if the number of processors is\nlow](#check-if-number-of-processors)\\n[7. Check if the quantity of monitors is\nsmall](#check-if-quantity-of-monitors)\\n[8. Check if the hard disk drive size and free space are\nsmall](#check-if-hard-disk)\\n[9. Check if the system uptime is small](#check-if-system-uptime)\\n[10. Check if the OS was boot from virtual hard disk\n(Win8+)](#check-if-os-was-boot-from-virtual-disk)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n### Signature recommendations are general\n\nSignature recommendations are general for each technique: hook the\nfunction used and track if it is called. It's pretty hard to tell why\napplication wants to get user name, for example. It doesn't necessarily\nmean applying evasion technique. So the best what can be done in this\nsituation is intercepting target functions and tracking their calls.\n\n\\n\n[Detection via generic OS checks]{#generic-os-queries .a-dummy}\n---------------------------------------------------------------\n\nUsual hosts have meaningful and non-standard usernames/computer names.\nParticular virtual environments assign some predefined names to default\nusers as well as computer names. Other differences between host OS and\nVMs include RAM size, HDD size, quantity of monitors - and so on. While\nthese may be not the most reliable ways to detect virtual environments,\nthey are still commonly used in malware samples.\n\n\\n\n### [1. Check if the username is specific]{#check-if-username-is-specific .a-dummy}\n\nPlease note that checks are not case-sensitive.\n\nFunction used:\n\n-   `GetUserNameA/W`\n\n\n**Code sample**\n\n    bool is_user_name_match(const std::string &s) {\n        auto out_length = MAX_PATH;\n        std::vector<uint8_t> user_name(out_length, 0);\n        ::GetUserNameA((LPSTR)user_name.data(), (LPDWORD)&out_length);\n\n        return (!lstrcmpiA((LPCSTR)user_name.data(), s.c_str()));\n    }\n\n*Code sample is taken from [InviZzzible\ntool](https://github.com/CheckPointSW/InviZzzible)*\n\n\n**Countermeasures**\n\nChange user name to non-suspicious one.\n\n\n**Detections table**\n\nCheck if username is one of the following:\n:::\n:::\n\nDetect\n\nString\n\n\[general\]\n\nadmin\n\nandy\n\nhoney\n\njohn\n\njohn doe\n\nmalnetvm\n\nmaltest\n\nmalware\n\nroo\n\nsandbox\n\nsnort\n\ntequilaboomboom\n\ntest\n\nvirus\n\nvirusclone\n\nwilbert\n\nNepenthes\n\nnepenthes\n\nNorman\n\ncurrentuser\n\nThreatExpert\n\nusername\n\nSandboxie\n\nuser\n\nVMware\n\nvmware\n\n\\n\n### [2. Check if the computer name is specific]{#check-if-computer-name-is-specific .a-dummy}\n\nPlease note that checks are not case-sensitive.\n\nFunction used:\n\n-   `GetComputerNameA/W`\n\n\n**Code sample**\n\n    bool is_computer_name_match(const std::string &s) {\n        auto out_length = MAX_PATH;\n        std::vector<uint8_t> comp_name(out_length, 0);\n        ::GetComputerNameA((LPSTR)comp_name.data(), (LPDWORD)&out_length);\n\n        return (!lstrcmpiA((LPCSTR)comp_name.data(), s.c_str()));\n    }\n\n*Code sample is taken from [InviZzzible\ntool](https://github.com/CheckPointSW/InviZzzible)*\n\n\n**Countermeasures**\n\nChange computer name to non-suspicious one.\n\n\n**Detections table**\n\nCheck if computer name is one of the following:\n\nDetect\n\nString\n\n\[generic\]\n\nklone\_x64-pc\n\ntequilaboomboom\n\nAnubis\n\nTU-4NH09SMCG1HC\n\nInsideTm\n\n\\n\n### [3. Check if the host name is specific]{#check-if-host-name-is-specific .a-dummy}\n\nPlease note that checks are not case-sensitive.\n\nFunction used:\n\n-   `GetComputerNameExA/W`\n\n\n**Code sample**\n\n    bool is_host_name_match(const std::string &s) {\n        auto out_length = MAX_PATH;\n        std::vector<uint8_t> dns_host_name(out_length, 0);\n        ::GetComputerNameExA(ComputerNameDnsHostname, (LPSTR)dns_host_name.data(), (LPDWORD)&out_length);\n\n        return (!lstrcmpiA((LPCSTR)dns_host_name.data(), s.c_str()));\n    }\n\n*Code sample is taken from [InviZzzible\ntool](https://github.com/CheckPointSW/InviZzzible)*\n\n\n**Countermeasures**\n\nChange host name to non-suspicious one.\n\n\n**Detections table**\n\nCheck if host name is one of the following:\n\nDetect\n\nString\n\n\[generic\]\n\nSystemIT\n\n\\n\n### [4. Check if the total RAM is low]{#check-if-total-ram-is-low .a-dummy}\n\nFunctions used to get executable path:\n\n-   `GetMemoryStatusEx`\n\n\n**Code sample**\n\n    BOOL memory_space()\n    {\n        DWORDLONG ullMinRam = (1024LL * (1024LL * (1024LL * 1LL))); // 1GB\n        \n        MEMORYSTATUSEX statex = {0};\n        statex.dwLength = sizeof(statex);\n        GlobalMemoryStatusEx(&statex); // calls NtQuerySystemInformation\n        \n        return (statex.ullTotalPhys < ullMinRam) ? TRUE : FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Countermeasures**\n\nPatch/hook NtQuerySystemInformation to return new number of\nPhysicalPages in SystemBasicInformation.\n\nTip: in this case its 1st argument is equal to 2 -\nSystemPerformanceInformation enum value.\n\nAlternatively, patch NumberOfPhysicalPages in KUSER\_SHARED\_DATA.\n\n\\n\n### [5. Check if the screen resolution is non-usual for host OS]{#check-if-screen-res .a-dummy}\n\nThe following set of functions is used:\n\n-   `GetDesktopWindow`\n-   `GetWindowRect`\n\nAlternatively:\n\n-   `GetSystemMetrics`\n-   `SystemParametersInfo`\n-   `GetMonitorInfo`\n\n\n**Code sample**\n\nTake a look at this [StackOverflow\nthread](https://stackoverflow.com/questions/4631292/how-detect-current-screen-resolution).\n\n\n**Countermeasures**\n\nChange screen resolution for it to match the resolution of usual host\n(1600x900, for example).\n\n\\n\n### [6. Check if the number of processors is low]{#check-if-number-of-processors .a-dummy}\n\nFunction used:\n\n-   `GetSystemInfo`\n\nBesides this function numbers of processors can be obtained from PEB,\nvia either asm inline or intrinsic function, see code samples below. It\ncan be also obtained (ActiveProcessorCount flag) from the\nKUSER\_SHARED\_DATA structure.\n\n\n**Code sample (variant 1, al-khaser project)**\n\n    BOOL NumberOfProcessors()\n    {\n    #if defined (ENV64BIT)\n     PULONG ulNumberProcessors = (PULONG)(__readgsqword(0x30) + 0xB8);\n    #elif defined(ENV32BIT)\n     PULONG ulNumberProcessors = (PULONG)(__readfsdword(0x30) + 0x64);\n    #endif\n\n        if (*ulNumberProcessors < 2)\n            return TRUE;\n        else\n            return FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Code sample (variant 2, al-khaser project, asm inline)**\n\n    __declspec(naked)\n    DWORD get_number_of_processors() {\n        __asm {\n            ; get pointer to Process Environment Block (PEB)\n            mov eax, fs:0x30\n\n            ; read the field containing target number\n            mov eax, [eax + 0x64]\n\n            ; return from function\n            retn\n        }\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Code sample (variant 3, pafish project)**\n\n    int gensandbox_one_cpu_GetSystemInfo() {\n        SYSTEM_INFO si;\n        GetSystemInfo(&si);\n        return si.dwNumberOfProcessors < 2 ? TRUE : FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Code sample (variant 4)**\n\n    __declspec(naked)\n        DWORD get_number_of_active_processors() {\n        __asm {\n            mov eax, 0x7ffe0000  ; KUSER_SHARED_DATA structure fixed address\n            mov eax, byte ptr [eax+0x3c0] ; checking ActiveProcessorCount\n            retn  ; return from function\n        }\n    }\n\n\n**Countermeasures**\n\nAssign two or more cores for Virtual Machine.\n\nAs an alternative solution, patch/hook NtCreateThread to assign specific\ncore for each new thread.\n\n\\n\n### [7. Check if the quantity of monitors is small]{#check-if-quantity-of-monitors .a-dummy}\n\nFunctions used:\n\n-   `EnumDisplayMonitors`\n-   `GetSystemMetrics (SM_MONITOR)`\n\n\n**Code sample**\n\n    BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData)\n    {\n        int *Count = (int*)dwData;\n        (*Count)++;\n        return TRUE;\n    }\n\n    int MonitorCount()\n    {\n        int Count = 0;\n        if (EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&Count))\n            return Count;\n        return -1; // signals an error\n    }\n\n*Credits for this code sample: [StackOverflow\nforum](https://stackoverflow.com/questions/7767036/how-do-i-get-the-number-of-displays-in-windows)*\n\n\n**Countermeasures**\n\nAdd at least one monitor to virtual environment.\n\n\\n\n### [8. Check if the hard disk drive size and free space are small]{#check-if-hard-disk .a-dummy}\n\nFunctions used:\n\n-   `DeviceIoControl(..., IOCTL_DISK_GET_LENGTH_INFO, ...)`\n-   `GetDiskFreeSpaceExA/W`\n\n\n**Code sample (checking drive total size)**\n\n    int gensandbox_drive_size() {\n        GET_LENGTH_INFORMATION size;\n        DWORD lpBytesReturned;\n\n        HANDLE drive = CreateFile("\\\\.\\PhysicalDrive0", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n        if (drive == INVALID_HANDLE_VALUE) {\n            // Someone is playing tricks. Or not enough privileges.\n            CloseHandle(drive);\n            return FALSE;\n        }\n        BOOL result = DeviceIoControl(drive, IOCTL_DISK_GET_LENGTH_INFO, NULL, 0, &size, sizeof(GET_LENGTH_INFORMATION), &lpBytesReturned, NULL);\n        CloseHandle(drive);\n\n        if (result != 0) {\n            if (size.Length.QuadPart / 1073741824 <= 60) /* <= 60 GB */\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Code sample (checking drive free space)**\n\n    int gensandbox_drive_size2() {\n        ULARGE_INTEGER total_bytes;\n\n        if (GetDiskFreeSpaceExA("C:\\", NULL, &total_bytes, NULL))\n        {\n            if (total_bytes.QuadPart / 1073741824 <= 60) /* <= 60 GB */\n            return TRUE;\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Countermeasures**\n\n*Against checking disk size:* filter IRP device control requests to\n\\\\Device\\\\HarddiskN with specific CTL-codes:\n\n-   `DRIVE_GEOMETRY_EX`\n-   `DRIVE_LAYOUT_EX`\n-   `PARTITION_INFO_EX`\n\n*Against checking free space:* patch/hook NtQueryVolumeInformationFile\nto process these classes:\n\n-   `FileFsSizeInformation`\n-   `FileFsFullSizeInformation`\n\nin case if handle points to \\\\Device\\\\HarddiskVolumeN.\n\n\\n\n### [9. Check if the system uptime is small]{#check-if-system-uptime .a-dummy}\n\nFunction used:\n\n-   `GetTickCount`\n-   `GetTickCount64`\n-   `NtQuerySystemInformation`\n\n**Code sample**\n\n    bool Generic::CheckSystemUptime() const {\n        const DWORD uptime = 1000 * 60 * 12; // 12 minutes\n        return GetTickCount() < uptime;\n    }\n\n*Code sample is taken from [InviZzzible\ntool](https://github.com/CheckPointSW/InviZzzible)*\n\n**Code sample**\n\n    #define MIN_UPTIME_MINUTES 12\n    BOOL uptime_check()\n    {\n        ULONGLONG uptime_minutes = GetTickCount64() / (60 * 1000);\n        return uptime_minutes < MIN_UPTIME_MINUTES;\n    }\n\n\\n**Code sample**\n\n    BOOL uptime_check2()\n    {\n        SYSTEM_TIME_OF_DAY_INFORMATION  SysTimeInfo;\n        ULONGLONG uptime_minutes;\n        NtQuerySystemInformation(SystemTimeOfDayInformation, &SysTimeInfo, sizeof(SysTimeInfo), 0);\n        uptime_minutes = (SysTimeInfo.CurrentTime.QuadPart - SysTimeInfo.BootTime.QuadPart) / (60 * 1000 * 10000);\n        return uptime_minutes < MIN_UPTIME_MINUTES;\n    }\n\n\n**Countermeasures**\n\n-   Adjust `KeBootTime` value\n-   Adjust `SharedUserData->TickCount`,\n    `SharedUserData->TickCoundLowDeprecated` values\n\n\\n\n### [10. Check if the OS was boot from virtual hard disk (Win8+)]{#check-if-os-was-boot-from-virtual-disk .a-dummy}\n\nFunction used:\n\n-   `IsNativeVhdBoot  // false on host OS, true within VM`\n\n**Code sample (excerpt from malware)**\n\nTake a look at the excerpt from malware\n[here](https://github.com/a0rtega/pafish/issues/46).\n\n\n**Code sample (pafish project)**\n\n    int gensandbox_IsNativeVhdBoot() {\n        BOOL isnative = FALSE;\n\n        IsNativeVhdBoot fnnative = (IsNativeVhdBoot) GetProcAddress(\n            GetModuleHandleA("kernel32"), "IsNativeVhdBoot");\n\n        /* IsNativeVhdBoot always returns 1 on query success */\n        if (fnnative)\n            fnnative(&isnative);\n            \n        return (isnative) ? TRUE : FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Countermeasures**\n\nHook IsNativeVhdBoot and change its result to the one required.\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nCountermeasures are present in appropriate sub-sections, see above.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source projects from where code samples were taken:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n-   pafish project on [github](https://github.com/a0rtega/pafish)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Global OS Objects {#evasions-global-os-objects .post-title-main itemprop="name headline"}\n===========================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Global objects detection methods](#global-objects-detection-methods)\\n[1. Check for specific global\nmutexes](#check-if-specific-mutexes-present)\\n[2. Check for specific virtual\ndevices](#check-if-specific-virtual-devices-present)\\n[3. Check for specific global pipes](#check-if-pipes-present)\\n[4. Check for specific global objects](#check-if-objects-present)\\n[5. Check for specific object directory (Sandboxie\nonly)](#check-if-object-directory-present)\\n[6. Check if virtual registry is present in system (Sandboxie\nonly)](#check-if-virtual-registry-present)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n[Global objects detection methods]{#global-objects-detection-methods .a-dummy}\n\nThe principle of all the global objects detection methods is the\nfollowing: there are no such objects in usual host; however they exist\nin particular virtual environments and sandboxes. Virtual environment\nmay be detected if such an artifact is present.\n\n\\n\n### [1. Check for specific global mutexes]{#check-if-specific-mutexes-present .a-dummy}\n\nThis method checks for particular mutexes which are present in virtual\nenvironments but not in usual host systems.\n\nFunctions used:\n\n-   `CreateMutexA/W`\n-   `OpenMutexA/W`\n\n\n**Code sample**\n\n    // usage sample:\n    supMutexExist(L"Sandboxie_SingleInstanceMutex_Control"); // sample value from the table below\n\n\n    BOOL supMutexExist(_In_ LPWSTR lpMutexName)\n    {\n        DWORD dwError;\n        HANDLE hObject = NULL;\n        if (lpMutexName == NULL) {\n            return FALSE;\n        }\n\n        SetLastError(0);\n        hObject = CreateMutex(NULL, FALSE, lpMutexName); // define around A or W function version\n        dwError = GetLastError();\n\n        if (hObject) {\n            CloseHandle(hObject);\n        }\n\n        return (dwError == ERROR_ALREADY_EXISTS);\n    }\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Signature recommendations**\n\nIf the following function contains 3rd argument from the table column\n\`Name\`:\n\n-   `CreateMutexA/W(..., ..., registry_path)`\n-   `OpenMutexA/W(..., ..., registry_path)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following global mutexes exist:\n:::\n:::\n\nDetect\n\nName\n\nDeepFreeze\n\nFrz\_State\n\nSandboxie\n\nSandboxie\_SingleInstanceMutex\_Control\n\nSBIE\_BOXED\_ServiceInitComplete\_Mutex1\n\nVirtualPC\n\nMicrosoftVirtualPC7UserServiceMakeSureWe\'reTheOnlyOneMutex\n\n\\nNote: DeepFreeze is an application restoring the system on each reboot.\n\n\\n\n### [2. Check for specific virtual devices]{#check-if-specific-virtual-devices-present .a-dummy}\n\nThis method checks for particular virtual devices which are present in\nvirtual environments but not in usual host systems.\n\nFunction used:\n\n-   `NtCreateFile`\n\n\n**Code sample**\n\n    // usage sample:\n    HANDLE hDummy = NULL;\n    supOpenDevice(L"\\Device\\Null", GENERIC_READ, &hDummy); // sample values from the table below\n\n\n    BOOL supOpenDevice(\n        _In_ LPWSTR lpDeviceName,\n        _In_ ACCESS_MASK DesiredAccess,\n        _Out_opt_ PHANDLE phDevice)\n    {\n        OBJECT_ATTRIBUTES attr;\n        IO_STATUS_BLOCK iost;\n        UNICODE_STRING uDevName;\n        HANDLE hDevice;\n        NTSTATUS Status;\n\n        if (phDevice) {\n            *phDevice = NULL;\n        }\n        if (lpDeviceName == NULL) {\n            return FALSE;\n        }\n\n        hDevice = NULL;\n        RtlSecureZeroMemory(&uDevName, sizeof(uDevName));\n        RtlInitUnicodeString(&uDevName, lpDeviceName);\n        InitializeObjectAttributes(&attr, &uDevName, OBJ_CASE_INSENSITIVE, 0, NULL);\n\n        Status = NtCreateFile(&hDevice, DesiredAccess, &attr, &iost, NULL, 0,\n            0, FILE_OPEN, 0, NULL, 0);\n        if (NT_SUCCESS(Status)) {\n            if (phDevice != NULL) {\n                *phDevice = hDevice;\n            }\n        }\n\n        return NT_SUCCESS(Status);\n    }\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Signature recommendations**\n\nIf the following function contains 3rd argument with its field\n\`ObjectName-\>Buffer\` from the table column \`Name\`:\n\n-   `NtCreateFile(..., ..., attr, ...)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\\n3rd argument is of the following type:\n\n    typedef struct _OBJECT_ATTRIBUTES {\n        ULONG Length;\n        HANDLE RootDirectory;\n        PUNICODE_STRING ObjectName;\n        ULONG Attributes;\n        PVOID SecurityDescriptor;\n        PVOID SecurityQualityOfService;\n    } OBJECT_ATTRIBUTES;\n\n\n**Detections table**\n\nCheck if the following virtual devices exist:\n\nDetect\n\nPath\n\nVirtualBox\n\n\\\\.\\VBoxMiniRdDN\n\n\\\\.\\VBoxMiniRdrDN\n\n\\\\.\\VBoxGuest\n\n\\\\.\\VBoxTrayIPC\n\n\\\\.\\VBoxMouse\n\n\\\\.\\VBoxVideo\n\nVMware\n\n\\\\.\\HGFS\n\n\\\\.\\vmci\n\n\\n\n### [3. Check for specific global pipes]{#check-if-pipes-present .a-dummy}\n\nPipes are just a particular case of virtual devices, please refer to the\n[previous section](#check-if-specific-virtual-devices-present) for code\nsample and signature recommendations.\n\n\n**Detections table**\n\nCheck if the following global pipes exist:\n\nDetect\n\nString\n\nVirtualBox\n\n\\\\.\\pipe\\VBoxMiniRdDN\n\n\\\\.\\pipe\\VBoxTrayIPC\n\n\\n\n### [4. Check for global objects]{#check-if-objects-present .a-dummy}\n\nThis method checks for particular global objects which are present in\nvirtual environments but not in usual host systems.\n\nFunctions used:\n\n-   `NtOpenDirectoryObject`\n-   `NtQueryDirectoryObject`\n\n\n**Code sample**\n\n    // usage sample:\n    supIsObjectExists(L"\\Driver", L"SbieDrv"); // sample values from the table below\n\n\n    typedef struct _OBJECT_DIRECTORY_INFORMATION {\n        UNICODE_STRING Name;\n        UNICODE_STRING TypeName;\n    } OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;\n\n    BOOL supIsObjectExists(\n        _In_ LPWSTR RootDirectory,\n        _In_ LPWSTR ObjectName)\n    {\n        OBJSCANPARAM Param;\n        if (ObjectName == NULL) {\n            return FALSE;\n        }\n\n        Param.Buffer = ObjectName;\n        Param.BufferSize = (ULONG)_strlen_w(ObjectName);\n\n        return NT_SUCCESS(supEnumSystemObjects(RootDirectory, NULL, supDetectObjectCallback, &Param));\n    }\n\n    NTSTATUS NTAPI supDetectObjectCallback(\n        _In_ POBJECT_DIRECTORY_INFORMATION Entry,\n        _In_ PVOID CallbackParam)\n    {\n        POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;\n        if (Entry == NULL) {\n            return STATUS_INVALID_PARAMETER_1;\n        }\n        if (CallbackParam == NULL) {\n            return STATUS_INVALID_PARAMETER_2;\n        }\n        if (Param->Buffer == NULL || Param->BufferSize == 0) {\n            return STATUS_MEMORY_NOT_ALLOCATED;\n        }\n        if (Entry->Name.Buffer) {\n            if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {\n                return STATUS_SUCCESS;\n            }\n        }\n\n        return STATUS_UNSUCCESSFUL;\n    }\n\n    NTSTATUS NTAPI supEnumSystemObjects(\n        _In_opt_ LPWSTR pwszRootDirectory,\n        _In_opt_ HANDLE hRootDirectory,\n        _In_ PENUMOBJECTSCALLBACK CallbackProc,\n        _In_opt_ PVOID CallbackParam)\n    {\n        BOOL cond = TRUE;\n        ULONG ctx, rlen;\n        HANDLE hDirectory = NULL;\n        NTSTATUS status;\n        NTSTATUS CallbackStatus;\n        OBJECT_ATTRIBUTES attr;\n        UNICODE_STRING sname;\n        POBJECT_DIRECTORY_INFORMATION objinf;\n\n        if (CallbackProc == NULL) {\n            return STATUS_INVALID_PARAMETER_4;\n        }\n        status = STATUS_UNSUCCESSFUL;\n        \n        __try {\n            // We can use root directory.\n            if (pwszRootDirectory != NULL) {\n                RtlSecureZeroMemory(&sname, sizeof(sname));\n                RtlInitUnicodeString(&sname, pwszRootDirectory);\n                InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n                status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);\n                if (!NT_SUCCESS(status)) {\n                    return status;\n                }\n            }\n            else {\n                if (hRootDirectory == NULL) {\n                    return STATUS_INVALID_PARAMETER_2;\n                }\n                hDirectory = hRootDirectory;\n            }\n\n            // Enumerate objects in directory.\n            ctx = 0;\n            do {\n                rlen = 0;\n                status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);\n                if (status != STATUS_BUFFER_TOO_SMALL)\n                        break;\n                objinf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, rlen);\n                if (objinf == NULL)\n                    break;\n                    \n                status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);\n                if (!NT_SUCCESS(status)) {\n                    HeapFree(GetProcessHeap(), 0, objinf);\n                    break;\n                }\n\n                CallbackStatus = CallbackProc(objinf, CallbackParam);\n                HeapFree(GetProcessHeap(), 0, objinf);\n                if (NT_SUCCESS(CallbackStatus)) {\n                    status = STATUS_SUCCESS;\n                    break;\n                }\n            } while (cond);\n\n            if (hDirectory != NULL) {\n                NtClose(hDirectory);\n            }\n        }\n        __except (EXCEPTION_EXECUTE_HANDLER) {\n            status = STATUS_ACCESS_VIOLATION;\n        }\n\n        return status;\n    }\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Detections table**\n\nCheck if the following global objects exist:\n\nDetect\n\nPath\n\nObject\n\nHyper-V\n\nVmGenerationCounter\n\n\\Device\n\nParallels\n\nprl\_pv\n\n\\Device\n\nprl\_tg\n\n\\Device\n\nprl\_time\n\n\\Device\n\nSandboxie\n\nSandboxieDriverApi\n\n\\Device\n\nSbieDrv\n\n\\Driver\n\nSbieSvcPort\n\n\\RPC Control\n\nVirtualBox\n\nVBoxGuest\n\n\\Device\n\nVBoxMiniRdr\n\n\\Device\n\nVBoxVideo\n\n\\Driver\n\nVBoxMouse\n\n\\Driver\n\nVirtualPC\n\nVirtualMachineServices\n\n\\Device\n\n1-driver-vmsrvc\n\n\\Driver\n\nVMware\n\nvmmemctl\n\n\\Device\n\n\\n\n### [5. Check for object directory (Sandboxie only)]{#check-if-object-directory-present .a-dummy}\n\nThis method checks for particular object directory which is present in\nSandboxie virtual environment but not in usual host systems.\n\nFunction used:\n\n-   `GetFileAttributes`\n\n\n**Code sample**\n\n    #define DIRECTORY_QUERY (0x0001)\n    #define OBJ_CASE_INSENSITIVE 0x00000040L\n    #define DIRECTORY_SANDBOXIE L"\\Sandbox"\n\n    int check_if_obj_dir_present() {\n        OBJECT_ATTRIBUTES attr;\n        UNICODE_STRING ustrName;\n        HANDLE hObject = NULL;\n\n        RtlSecureZeroMemory(&ustrName, sizeof(ustrName));\n        RtlInitUnicodeString(&ustrName, DIRECTORY_SANDBOXIE);\n        InitializeObjectAttributes(&attr, &ustrName, OBJ_CASE_INSENSITIVE, NULL, NULL);\n\n        if (NT_SUCCESS(NtOpenDirectoryObject(&hObject, DIRECTORY_QUERY, &attr))) {\n            NtClose(hObject);\n            return TRUE;\n        }\n        \n        return FALSE;\n    }\n\n*Credits for this code sample: [VMDE\nproject](https://github.com/hfiref0x/VMDE)*\n\n\n**Signature recommendations**\n\nIf the following function contains 3rd argument with its field\n\"ObjectName-\>Buffer\" from the table column \`Name\`:\n\n-   `NtOpenDirectoryObject(..., ..., attr, ...)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\\n3rd argument is of the following type:\n\n    typedef struct _OBJECT_ATTRIBUTES {\n        ULONG Length;\n        HANDLE RootDirectory;\n        PUNICODE_STRING ObjectName;\n        ULONG Attributes;\n        PVOID SecurityDescriptor;\n        PVOID SecurityQualityOfService;\n    } OBJECT_ATTRIBUTES;\n\n\n**Detections table**\n\nCheck if the following object directory exists:\n\nDetect\n\nPath\n\nSandboxie\n\n\\Sandbox\n\n\\n\n### [6. Check if virtual registry is present in OS (Sandboxie only)]{#check-if-virtual-registry-present .a-dummy}\n\nThis method checks for virtual registry which is present in Sandboxie\nvirtual environment but not in usual host systems.\n\nApplication opens registry key \\REGISTRY\\USER. It uses the following\nfunction in order to check real object name:\n\n    NtQueryObject(\n        hUserKey,\n        ObjectNameInformation,\n        oni, // OBJECT_NAME_INFORMATION object\n        Size,\n        NULL);\n\nIf received OBJECT\_NAME\_INFORMATION object name does not equal to the\n\"\\REGISTRY\\USER\", then application assumes that it runs inside\nSandboxie environment.\n\n\n**Signature recommendations**\n\nIf the following function is used for opening \\REGISTRY\\USER:\n\n-   `NtOpenKey`\n\nand is followed by the call of the following function with its 1st\nargument being the handle of \\REGISTRY\\USER key:\n\n-   `NtQueryObject(hUserKey, ...)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nHook target functions and return appropriate results if indicators\n(objects from tables) are triggered. In some cases stopping appropriate\ndevice may help --- but it's not a universal counter-action: not all\nglobal objects are devices.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   VMDE project on [github](https://github.com/hfiref0x/VMDE)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Hardware {#evasions-hardware .post-title-main itemprop="name headline"}\n==================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Hardware info detection methods](#hardware-detection-methods)\\n[1. Check if HDD has specific name](#check-if-hdd-has-specific-name)\\n[2. Check if HDD Vendor ID has specific\nvalue](#check-if-hdd-vendor-id-has-specific-value)\\n[3. Check if audio device is absent](#check-if-audio-device-is-absent)\\n[4. Check if CPU temperature information if\navailable](#check-if-cpu-temperature-information-is-available)\\n[5. Check physical display adapter for IDirect3D9\ninterface](#check-directx-adapter)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures-sandboxie)\\n\\n\n\n[Hardware info detection methods]{#hardware-detection-methods .a-dummy}\n-----------------------------------------------------------------------\n\nVirtual environments emulate hardware devices and leave specific traces\nin their descriptions - which may be queried and the conclusion about\nnon-host OS made.\n\n\\n\n### [1. Check if HDD has specific name]{#check-if-hdd-has-specific-name .a-dummy}\n\nFunctions used:\n\n-   `SetupDiGetClassDevs`\n-   `SetupDiEnumDeviceInfo`\n-   `SetupDiGetDeviceRegistryProperty`\n\n\n**Code sample**\n\n    hDevs = SetupDiGetClassDevs(\n        &guid,  // GUID_DEVCLASS(DEVINTERFACE)_DISKDRIVE\n        NULL,\n        NULL,\n        DIGCF_PRESENT);\n\n    SetupDiEnumDeviceInfo(\n        hDevsInfo,\n        0,\n        &devinfo);  // PSP_DEVINFO_DATA\n\n    SetupDiGetDeviceRegistryProperty(\n        hDevs,\n        &devinfo,\n        SPDRP_FRIENDLYNAME,\n        &dword_1,\n        szFriendlyName,  // HDD name will be here\n        dFriendlyNameSize,\n        &dword_2);\n\n\n**Detections table**\n\nCheck if hard disk drive has one of the following names:\n:::\n:::\n\nDetect\n\nName\n\nQEMU\n\nQEMU\n\nVirtualBox\n\nVBOX\n\nVirtualPC\n\nVIRTUAL HD\n\nVMware\n\nVMware\n\n\\n\n### [2. Check if HDD Vendor ID has specific value]{#check-if-hdd-vendor-id-has-specific-value .a-dummy}\n\nThe following function is used:\n\n-   `DeviceIoControl(..., IOCTL_STORAGE_QUERY_PROPERTY, ...)`\n\n\n**Code sample**\n\n    bool GetHDDVendorId(std::string& outVendorId) {\n        HANDLE hDevice = CreateFileA(_T("\\\\.\\PhysicalDrive0"), \n                                     0, \n                                     FILE_SHARE_READ | FILE_SHARE_WRITE, \n                                     0, \n                                     OPEN_EXISTING, \n                                     0, \n                                     0);\n        if (hDevice == INVALID_HANDLE_VALUE)\n            return false;\n        \n        STORAGE_PROPERTY_QUERY storage_property_query = {};\n        storage_property_query.PropertyId = StorageDeviceProperty;\n        storage_property_query.QueryType = PropertyStandardQuery;\n        STORAGE_DESCRIPTOR_HEADER storage_descriptor_header = {};\n        DWORD BytesReturned = 0;\n      \n        if (!DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, \n                             &storage_property_query, sizeof(storage_property_query), \n                             &storage_descriptor_header, sizeof(storage_descriptor_header), \n                             &BytesReturned, )) {\n            printf("DeviceIoControl() for size query failed\n");\n            CloseHandle(hDevice);\n            return false;\n        }\n        if (!BytesReturned) {\n            CloseHandle(hDevice);\n            return false;\n        }\n      \n        std::vector<char> buff(storage_descriptor_header.Size); //_STORAGE_DEVICE_DESCRIPTOR\n        if (!DeviceIoControl(hDevice, IOCTL_STORAGE_QUERY_PROPERTY, \n                             &storage_property_query, sizeof(storage_property_query), \n                             buff.data(), buff.size(), 0)) {\n            CloseHandle(hDevice);\n            return false;\n        }\n      \n        CloseHandle(hDevice);\n      \n        if (BytesReturned) {\n            STORAGE_DEVICE_DESCRIPTOR* device_descriptor = (STORAGE_DEVICE_DESCRIPTOR*)buff.data();\n            if (device_descriptor->VendorIdOffset)\n                outVendorId = &buff[device_descriptor->VendorIdOffset];\n      \n            return true;\n        }\n        \n        return false;\n    }\n\n\n**Detections table**\n\nCheck if HDD Vendor ID is one of the following:\n\nDetect\n\nName\n\nVirtualBox\n\nVBOX\n\nVMware\n\nvmware\n\n\\n\n### [3. Check if audio device is absent]{#check-if-audio-device-is-absent .a-dummy}\n\nThis technique was extracted from TeslaCrypt malware sample and was\ndescribed [in this Joe Security blog\npost](https://www.joesecurity.org/blog/6933341622592617830).\n\n\n**Code sample**\n\n    void AudioEvasion() {\n      PCWSTR wszfilterName = L"audio_device_random_name";\n\n      if (FAILED(CoInitialize(NULL)))\n        return;\n\n      IGraphBuilder *pGraph = nullptr;\n      if (FAILED(CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER, IID_IGraphBuilder, (void**)&pGraph)))\n        return;\n\n      if (E_POINTER != pGraph->AddFilter(NULL, wszfilterName))\n        ExitProcess(-1);\n\n      IBaseFilter *pBaseFilter = nullptr;\n      CoCreateInstance(CLSID_AudioRender, NULL, CLSCTX_INPROC_SERVER, IID_IBaseFilter, (void**)&pBaseFilter);\n      \n      pGraph->AddFilter(pBaseFilter, wszfilterName);\n\n      IBaseFilter *pBaseFilter2 = nullptr;\n      pGraph->FindFilterByName(wszfilterName, &pBaseFilter2);\n      if (nullptr == pBaseFilter2)\n        ExitProcess(1);\n\n      FILTER_INFO info = { 0 };\n      pBaseFilter2->QueryFilterInfo(&info);\n      if (0 != wcscmp(info.achName, wszfilterName))\n        return;\n\n      IReferenceClock *pClock = nullptr;\n      if (0 != pBaseFilter2->GetSyncSource(&pClock))\n        return;\n      if (0 != pClock)\n        return;\n\n      CLSID clsID = { 0 };\n      pBaseFilter2->GetClassID(&clsID);\n      if (clsID.Data1 == 0)\n        ExitProcess(1);\n\n      if (nullptr == pBaseFilter2)\n        ExitProcess(-1);\n\n      IEnumPins *pEnum = nullptr;\n      if (0 != pBaseFilter2->EnumPins(&pEnum))\n        ExitProcess(-1);\n\n      if (0 == pBaseFilter2->AddRef())\n        ExitProcess(-1);\n    }\n\n\\n\n### [4. Check if CPU temperature information is available]{#check-if-cpu-temperature-information-is-available .a-dummy}\n\nThis technique was extracted from GravityRAT malware and is described\n[by this\nlink](https://blog.talosintelligence.com/2018/04/gravityrat-two-year-evolution-of-apt.html).\n\n\n**Code sample (Windows cmd command)**\n\n    wmic /namespace:\\root\WMI path MSAcpi_ThermalZoneTemperature get CurrentTemperature\n\n\\n\n### [5. Check physical display adapter for IDirect3D9 interface]{#check-directx-adapter .a-dummy}\n\nThis method checks physical display adapters present in the system when\nthe IDirect3D9 interface was instantiated. It works on all Windows\nversions starting from Windows XP.\n\nFunctions used:\n\n-   `Direct3DCreate9` - called from \`d3d9.dll\` library\n-   `GetAdapterIdentifier` - called via IDirect3D9 interface\n\n\n**Code sample**\n\n    #include <d3d9.h>\n\n    // https://github.com/qt/qtbase/blob/dev/src/plugins/platforms/windows/qwindowsopengltester.cpp#L124\n\n    void detect() {\n        typedef IDirect3D9* (WINAPI* PtrDirect3DCreate9)(UINT);\n\n        HMODULE d3d9lib = ::LoadLibraryA("d3d9");\n        if (!d3d9lib)\n            return;\n\n        PtrDirect3DCreate9 direct3DCreate9 = (PtrDirect3DCreate9)GetProcAddress(d3d9lib, "Direct3DCreate9");\n        if (!direct3DCreate9)\n            return;\n\n        IDirect3D9* direct3D9 = direct3DCreate9(D3D_SDK_VERSION);\n        if (!direct3D9)\n            return;\n\n        D3DADAPTER_IDENTIFIER9 adapterIdentifier;\n        const HRESULT hr = direct3D9->GetAdapterIdentifier(0, 0, &adapterIdentifier);\n        direct3D9->Release();\n\n        if (SUCCEEDED(hr)) {\n            printf("VendorId:    0x%x\n", adapterIdentifier.VendorId);\n            printf("DeviceId:    0x%x\n", adapterIdentifier.DeviceId);\n            printf("Driver:      %s\n", adapterIdentifier.Driver);\n            printf("Description: %s\n", adapterIdentifier.Description);\n        }\n    }\n\n*Credits for this code sample go to\n[elsamuko](https://gist.github.com/elsamuko/d3049d52ca235112c99ac3ee30282846)\nwho pointed it out*.\n\n\nExample of output on a usual host machine is provided below:\n\n    VendorId:    0x10de\n    DeviceId:    0x103c\n    Driver:      nvldumdx.dll\n    Description: NVIDIA Quadro K5200\n\nAnd here is an example of output on a virtual machine (VMware):\n\n    VendorId:    0x15ad\n    DeviceId:    0x405\n    Driver:      vm3dum64_loader.dll\n    Description: VMware SVGA 3D\n\nExamined fields are named after the corresponding fields of\nD3DADAPTER\_IDENTIFIER9 structure. Malware can compare values in these\nfields to the ones which are known to be present inside the virtual\nmachine and if match is found, then it draws the conclusion that it's\nrun under virtual machine.\n\n**Detections table**\n\nCheck if the following values are present in the fields of\nD3DADAPTER\_IDENTIFIER9 structure:\n\nDetect\n\nStructure field\n\nValue\n\nComment\n\nVMware\n\nVendorId\n\n0x15AD\n\nDeviceId\n\n0x405\n\nOnly when used in combination with VendorId related to VMware (0x15AD)\n\nDriver\n\nvm3dum.dll\n\nDriver\n\nvm3dum64\_loader.dll\n\nDescription\n\nVMware SVGA 3D\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*Signature recommendations are general for each technique: hook the\nfunction used and track if it is called. It's pretty hard to tell why\napplication wants to get HDD name, for example. It doesn't necessarily\nmean applying evasion technique. So the best what can be done in this\nsituation is intercepting target functions and tracking their calls.*\n\n\\n\n### [Countermeasures]{#countermeasures-sandboxie .a-dummy}\n\n-   `versus HDD checks:` rename HDD so that it\'s not detected by\n    specific strings;\n-   `versus audio device check:` add audio device;\n-   `versus CPU temperature check:` add stub to hypervisor to output\n    some meaningful information;\n-   `versus physical display adapter check:` set up hook on a function\n    GetAdapterIdentifier from d3d9.dll, check if the queried adapter is\n    related to DirectX and replace return values.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Hooks {#evasions-hooks .post-title-main itemprop="name headline"}\n===============\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Hooks detection methods](#hooks-detection-methods)\\n[1. Check whether hooks are set within system\nfunctions](#check-whether-hooks-are-set-within-system-functions)\\n[2. Check user clicks via mouse\nhooks](#check-user-clicks-via-mouse-hooks)\\n[3. Check for incorrectly hooked\nfunctions](#check-incorrectly-hooked-functions)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[Hooks detection methods]{#hooks-detection-methods .a-dummy}\n------------------------------------------------------------\n\nTechniques described here make use of hooks either to detect user\npresence or as means to be checked whether some unusual-for-host-OS\nhooks installed.\n\n\\n\n### [1. Check whether hooks are set within system functions]{#check-whether-hooks-are-set-within-system-functions .a-dummy}\n\nMalware reads memory at specific addresses to check if Windows API\nfunctions are hooked.\\nThis method is based on the fact, that emulation environments are most\nlikely to hook these functions to be able to gather data and statistics\nduring an emulation.\n\n\nPopular functions to be checked:\n\n-   `ReadFile`\n-   `DeleteFile`\n-   `CreateProcessA/W`\n\n\nReading memory is accomplished via the following functions:\n\n-   `ReadProcessMemory`\n-   `NtReadVirtualMemory`\n\n\nThen different algorithms may be used for checking:\n\n-   Comparing first two bytes with `\x8B\xFF (mov edi, edi)` --- typical\n    prologue start for `kernel32` functions.\n-   Comparing first N bytes with `\xCC` - software breakpoint (`int 3`),\n    not connected with hooks directly but still a suspicious behavior.\n-   Comparing first N bytes with `\xE9` (`call`) or with `\xEB` (`jmp`\n    instruction) --- typical instructions for redirecting execution.\n-   Checking for `push/ret` combo for execution redirection.\n\nand so on.\n\n\nIt's pretty tricky to count for every possible comparison so general\nindication of something unusual in application's behavior is reading\nmemory where OS libraries reside. If to be more precise: reading memory\nwhere "interesting" functions are situated.\n\n\n[This\natricle](https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496)\nexplains how to detect user-mode hooks and remove them. The following\ncode samples are taken from the article.\n\n\n**Example of hook detection**\n\n    HOOK_TYPE IsHooked(LPCVOID lpFuncAddress, DWORD_PTR *dwAddressOffset) {\n        LPCBYTE lpBytePtr = (LPCBYTE)lpFuncAddress;\n\n        if (lpBytePtr[0] == 0xE9) {\n            *dwAddressOffset = 1;\n            return HOOK_RELATIVE;    // E9 jmp is relative.\n        } else if (lpBytePtr[0] == 0x68 &&  lpBytePtr[5] == 0xC3) {\n            *dwAddressOffset = 1;\n            return HOOK_ABOLSUTE;    // push/ret is absolute.\n        }\n\n        return HOOK_NONE;            // No hook.\n    }\n\n    LPVOID lpFunction = ...;\n    DWORD_PTR dwOffset = 0;\n    LPVOID dwHookAddress = 0;\n\n    HOOK_TYPE ht = IsHooked(lpFunction, &dwOffset);\n    if (ht == HOOK_ABSOLUTE) {\n        // 1. Get the pointer to the address (lpFunction + dwOffset)\n        // 2. Cast it to a DWORD pointer\n        // 3. Dereference it to get the DWORD value\n        // 4. Cast it to a pointer\n        dwHookAddress = (LPVOID)(*(LPDWORD)((LPBYTE)lpFunction + dwOffset));\n    } else if (ht == HOOK_RELATIVE) {\n        // 1. Get the pointer to the address (lpFunction + dwOffset)\n        // 2. Cast it to an INT pointer\n        // 3. Dereference it to get the INT value (this can be negative)\n        INT nJumpSize = (*(PINT)((LPBYTE)lpFunction  + dwOffset);\n        // 4. E9 jmp starts from the address AFTER the jmp instruction\n        DWORD_PTR dwRelativeAddress = (DWORD_PTR)((LPBYTE)lpFunction + dwOffset + 4));\n        // 5. Add the relative address and jump size\n        dwHookAddress = (LPVOID)(dwRelativeAddress + nJumpSize);\n    }\n\n\n**Example of unhooking functions**\n\n    // Parse the PE headers.\n    PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)lpMapping;\n    PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpMapping + pidh->e_lfanew);\n\n    // Walk the section headers and find the .text section.\n    for (WORD i = 0; i < pinh->FileHeader.NumberOfSections; i++) {\n        PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pinh) + \n                                     ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));\n        if (!strcmp(pish->Name, ".text")) {\n            // Deprotect the module's memory region for write permissions.\n            DWORD flProtect = ProtectMemory(\n                (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish->VirtualAddress),    // Address to protect.\n                pish->Misc.VirtualSize,                        // Size to protect.\n                PAGE_EXECUTE_READWRITE                         // Desired protection.\n            );\n\n            // Replace the hooked module's .text section with the newly mapped module's.\n            memcpy(\n                (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish->VirtualAddress),\n                (LPVOID)((DWORD_PTR)lpMapping + (DWORD_PTR)pish->VirtualAddress),\n                pish->Misc.VirtualSize\n            );\n\n            // Reprotect the module's memory region.\n            flProtect = ProtectMemory(\n                (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish->VirtualAddress),    // Address to protect.\n                pish->Misc.VirtualSize,                        // Size to protect.\n                flProtect                                      // Revert to old protection.\n            );\n        }\n    }\n\n\n\\n\n### [2. Check user clicks via mouse hooks]{#check-user-clicks-via-mouse-hooks .a-dummy}\n\nThis technique is described [by this\nlink](https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf)\n(p.4, p.7).\n\n\nMalware sets mouse hook to detect a click (or more) if it occurs. If\nit's the case malware treats the host a usual one, i.e., with end user\nbehind the screen - not a virtual environment. If no mouse click is\ndetected then it's very likely a virtual environment.\n\n\nFunctions used:\n\n-   `SetWindowsHookExA/W (WH_MOUSE_LL, ...)`\n-   `GetAsyncKeyState`\n\n\n**Code sample (`SetWindowsHookExA`)**\n\n    HHOOK g_hhkMouseHook = NULL;\n\n    LRESULT CALLBACK mouseHookProc(int nCode, WPARAM wParam, LPARAM lParam)\n    {\n      switch (wParam)\n      {\n      case WM_MOUSEMOVE:\n        // ...\n        break;\n      case WM_NCLBUTTONDOWN:\n        // ...\n        break;\n      case WM_LBUTTONUP:\n        UnhookWindowsHookEx(g_hhkMouseHook);\n        CallMaliciousCode();\n        ExitProcess(0);\n      }\n      return CallNextHookEx(g_hhkMouseHook, nCode, wParam, lParam);\n    }\n\n    g_hhkMouseHook = SetWindowsHookEx(WH_MOUSE_LL, mouseHookProc, GetModuleHandleA(NULL), NULL);\n\n\n**Code sample (`GetAsyncKeyState`)**\n\n    std::thread t([]()\n    {\n      int count = 0;\n      while (true)\n      {\n        if (GetAsyncKeyState(VK_LBUTTON) || GetAsyncKeyState(VK_RBUTTON) || GetAsyncKeyState(VK_MBUTTON))\n        {\n          if (++count == 2)\n            break;\n        }\n        Sleep(100);\n      }\n      CallMaliciousCode();\n    });\n    t.join();\n\n\\n\n### [3. Check for incorrectly hooked functions]{#check-incorrectly-hooked-functions .a-dummy}\n\nThere are more than 400 Native API functions (or Nt-functions) in\n`ntdll.dll` that are usually hooked in sandboxes. In such a large list,\nthere is enough space for different kinds of mistakes. We checked the\nhooked Nt-functions in popular sandboxes and found several issues. On of\nthem is a lack of necessary checks for arguments in a hooked function.\nThis case is described our article "[Timing: Call a potentially hooked\ndelay function with invalid arguments\nevasions](timing.html#call-hooked-function-with-invalid-arguments)"\\nAnother issue we found is a discrepancy in the number of arguments in a\nhooked and an original function. If a function is hooked incorrectly, in\nkernel mode this may lead an operating system to crash. Incorrect\nuser-mode hooks are not as critical. However, they may lead an analyzed\napplication to crash or can be easily detected. For example, let's look\nat the `NtLoadKeyEx` function. It was first introduced in Windows Server\n2003 and had only 4 arguments. Starting from Windows Vista up to the\nlatest version of Windows 10, it has 8 arguments:\n\n::: {.language-plaintext .highlighter-rouge}\n::: {.highlight}\n``` {.highlight}\n; Exported entry 318. NtLoadKeyEx\n; Exported entry 1450. ZwLoadKeyEx\n; __stdcall NtLoadKeyEx(x, x, x, x, x, x, x, x)\npublic _NtLoadKeyEx@32\n```\n:::\n:::\n\nHowever, in the Cuckoo monitor, the `NtLoadKeyEx` declaration still has\nonly [4\narguments](https://github.com/cuckoosandbox/monitor/blob/8c419e6216f379e01ea0caa3a71142543e10fc04/sigs/registry_native.rst#ntloadkeyex):\n\n::: {.language-plaintext .highlighter-rouge}\n::: {.highlight}\n``` {.highlight}\n*  POBJECT_ATTRIBUTES TargetKey\n*  POBJECT_ATTRIBUTES SourceFile\n** ULONG Flags flags\n** HANDLE TrustClassKey trust_class_key\n```\n:::\n:::\n\nWe found this legacy prototype used in other sources as well. For\nexample, [CAPE\nmonitor](https://github.com/kevoreilly/capemon/blob/a3fe72ad9d3f9cd45aa2f5d503a5328ab1f9e442/hooks.h#L710)\nhas the same issue:\n\n    extern HOOKDEF(NTSTATUS, WINAPI, NtLoadKeyEx,\n        __in      POBJECT_ATTRIBUTES TargetKey,\n        __in      POBJECT_ATTRIBUTES SourceFile,\n        __in      ULONG Flags,\n        __in_opt  HANDLE TrustClassKey\n    );\n\nTherefore, if a sandbox uses any recent Windows OS, this function is\nhooked incorrectly. After the call to the incorrectly hooked function,\nthe stack pointer value becomes invalid. Therefore, a totally\n"legitimate" call to the `RegLoadAppKeyW` function, which calls\n`NtLoadKeyEx`, leads to an exception. This fact can be used to evade\nCuckoo and CAPE sandbox with just a single call to the `RegLoadAppKeyW`\nfunction.\n\n**Code sample**\n\n    RegLoadAppKeyW(L"storage.dat", &hKey, KEY_ALL_ACCESS, 0, 0);\n    // If the application is running in a sandbox an exception will occur\n    // and the code below will not be executed.\n\n    // Some legitimate code that works with hKey to distract attention goes here\n    // ...\n    RegCloseKey(hKey);\n    // Malicious code goes here\n    // ...\n\nInstead of using `RegLoadAppKeyW`, we can call the `NtLoadKeyEx`\nfunction directly and check the ESP value after the call.\n\n**Code sample**\n\n    __try\n    {\n        _asm mov old_esp, esp\n        NtLoadKeyEx(&TargetKey, &SourceFile, 0, 0, 0, KEY_ALL_ACCESS, &hKey, &ioStatus);\n        _asm mov new_esp, esp\n        _asm mov esp, old_esp\n        if (old_esp != new_esp)\n            printf("Sandbox detected!");\n    }\n    __except (EXCEPTION_EXECUTE_HANDLER)\n    {\n        printf("Sandbox detected!");\n    }\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*No signature recommendations are provided for this evasion group as\nit's hard to make a difference between the code which aims for some\nevasion technique and the one which is "legally used".*\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\n-   `versus function hook checks:` set kernel mode hooks; second\n    solution is to use stack routing to implement function hooking;\n-   `versus mouse click checks via hooks:` use mouse movement emulation\n    module.\n-   `versus incorrect function hooks:` ensure all the hooked function\n    have the same number of arguments as the original functions\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to user `dtm` from [0x00sec.org](https://0x00sec.org/) forum.\n\nDue to modular code structure of the Check Point's tool called\nInviZzzible it would require more space to show a code sample from this\ntool for the same purposes. That's why we've decided to use other great\nopen-source projects for examples throughout the encyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Human-like behavior {#evasions-human-like-behavior .post-title-main itemprop="name headline"}\n=============================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Human-like behavior detection\nmethods](#human-like-behavior-detection-methods)\\n[1. General detection methods via\nregistry](#general-detection-methods-via-registry)\\n[1.1. Check the number of recently opened\ndocuments](#check-number-of-recently-opened-documents)\\n[1.2. Check if the browser history contains at least 10\nURLs](#check-if-browser-history-contains-at-least-10-urls)\\n[1.3. Check if certain software packages were\ninstalled](#check-if-certain-software-package-were-installed)\\n[1.4.\nCountermeasures](#general-detection-methods-via-registry-countermeasures)\\n[2. Check for user presence at the moment of executing a\nprocess](#check-user-presence-at-the-moment-of-executing)\\n[2.1. Check the mouse movement](#check-mouse-movement)\\n[2.2. Check via a request for user\ninteraction](#check-via-request-for-user-interaction)\\n[2.3. Evasion technique for the Cuckoo human-interaction\nmodule](#evasion-technique-for-cuckoo-human-interaction-module)\\n[2.4. No suspicious actions until a document is scrolled\ndown](#no-suspicious-actions-until-a-document-is-scrolled-down)\\n[2.5. Check user activity via\nGetLastInputInfo](#check-user-activity-via-getlastinputinfo)\\n[Countermeasures](#countermeasures)\\n[Signature recommendations](#signature-recommendations)\\n[Credits](#credits)\\n\\n\n\n[Human-like behavior detection methods]{#human-like-behavior-detection-methods .a-dummy}\n\nAll the techniques described in this group make use of the fact that\ncertain actions are performed differently by a user and by a virtual\nenvironment.\n\n\\n\n### [1. General detection methods via registry]{#general-detection-methods-via-registry .a-dummy}\n\nThe registry is a storage for different pieces of information. For\nexample, recently opened URLs and documents, and software installation\nnotes are stored here. All of these may be used to determine if the\nmachine is operated by a human user and is not a sandbox.\n\n\\n\n#### [1.1. Check the number of recently opened documents]{#check-number-of-recently-opened-documents .a-dummy}\n\nIt's hard to imagine a typical host system where the user does not open\nany documents. Therefore, the lack of recently opened documents\nindicates this is likely a virtual environment.\n\n\n**Code sample (VB)**\n\n    Public Function DKTxHE() As Boolean\n    DKTxHE = RecentFiles.Count < 3\n    End Function\n\n*This code sample was taken from [SentinelOne\narticle](https://www.sentinelone.com/blog/anti-vm-tricks/)*\n\n\\n\n#### [1.2. Check if the browser history contains at least 10 URLs]{#check-if-browser-history-contains-at-least-10-urls .a-dummy}\n\nIt's hard to imagine a typical host system where the user does not\nbrowse the Internet. Therefore, if there are fewer than 10 URLs in the\nbrowser history, this is likely a sandbox or VM.\n\n\n**Code sample (for Chrome)**\n\n    bool chrome_history_evasion(int min_websites_visited = 10)\n    {\n      sqlite3 *db;\n      int rc;\n      bool vm_found = false;\n\n      rc = sqlite3_open("C:\\Users\\<USER_NAME>\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\History", &db);\n      if (!rc)\n      {\n        char **results = nullptr;\n        char *error = nullptr;\n        int rows, columns;\n\n        rc = sqlite3_get_table(db, "SELECT DISTINCT title FROM urls;", &results, &rows, &columns, &error);\n        if (!rc)\n          vm_found = rows < min_websites_visited;\n        sqlite3_free_table(results);\n      }\n\n      sqlite3_close(db);\n      return vm_found;\n    }\n\n\\n\n#### [1.3. Check if certain software packages were installed]{#check-if-certain-software-package-were-installed .a-dummy}\n\nIf the system is only used for simulation purposes then it is likely to\nhave many fewer installed software packages than a usual user's work\nmachine. The installed packages may be specific to emulation purposes,\nnot the ones that are usually used by human operators. Therefore, the\nlist of installed packages may be compared to the list of commonly used\napplications to determine if it's a sandbox.\n\n\n**Code sample (PowerShell)**\n\n    Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Format-Table -AutoSize | Measure-Object -Line\n\n\\n\n#### [1.4. Countermeasures]{#general-detection-methods-via-registry-countermeasures .a-dummy}\n\nCountermeasures are simple:\n\n-   open few documents to update the recent history\n-   open few internet URLs to create a browsing history\n-   install some lightweight software (like Notepad++)\n\n\\n\n### [2. Check for user presence at the moment of executing a process]{#check-user-presence-at-the-moment-of-executing .a-dummy}\n\nThe following sub-group leverages the differences between a user's\ninteraction with the machine and the actions of a virtual environment.\n\n\\n\n#### [2.1. Check the mouse movement]{#check-mouse-movement .a-dummy}\n\nThis method relies on the fact that a user frequently moves the mouse\nduring actual work.\n\n\nSome sandboxes and antivirus virtual machines have a static cursor\nposition because they do not emulate any user activity while\nautomatically running the files.\n\n\n**Code sample**\n\n    int gensandbox_mouse_act() {\n        POINT position1, position2;\n\n        GetCursorPos(&position1);\n        Sleep(2000);\n        GetCursorPos(&position2);\n\n        if ((position1.x == position2.x) && (position1.y == position2.y))\n            // No mouse activity during the sleep.\n            return TRUE;\n        else\n            return FALSE;\n    }\n\n*This code sample was taken from [pafish\nproject](https://github.com/a0rtega/pafish)*\n\nSuch a short delay of only 2 seconds implies that the user should be\nactive at the moment of infection.\n\n\nMore sophisticated checks rely on detection of not only the mouse\nmovement per se but the pattern of such movement. The following example\nis taken from the research of [LummaC2\nStealer](https://outpost24.com/blog/lummac2-anti-sandbox-technique-trigonometry-human-detection/)\nconducted by Outpost24.\n\nFirst, malware captures mouse movements with the delay of 50 msec\nbetween them.\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/trigonometry_mouse_check_1.webp)\\n:::\n\n\nSecond, the vectors are drawn out of paired captured positions.\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/trigonometry_mouse_check_2.webp)\\n:::\n\n\nNext, the angles are calculated between the corresponding vectors.\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/trigonometry_mouse_check_3.webp)\\n:::\n\n\nFinally, the angles are compared with the 45.0º threshold value, and if\nany of the angles is bigger than this hardcoded value, malware treats\nthe result as being suspicious and does not execute the malicious code.\n\n\n**Countermeasures**\n\nImplement the module for mouse movement during a sample emulation. Make\nsure to come up with a more delicate way of interacting with the mouse\ncursor rather than just random movements all around the screen, so that\nit resembles the behavior of a human being.\n\n\\n\n#### [2.2. Check via a request for user interaction]{#check-via-request-for-user-interaction .a-dummy}\n\nSome malware samples contain a GUI installer which requires user\ninteraction. For example, the user must click the "Install" or "Next"\nbuttons. Therefore, the malware may take no action unless the button is\nclicked. Standard sandboxes like Cuckoo have a module which simulates\nuser activity. It searches for and clicks buttons with the captions\nmentioned above.\n\n\nTo prevent auto-clicking, a malware sample may create buttons with a\nclass name that differs from "Button" or with a different caption (not\n"Install" or "Next"). This way the sandbox can't detect and click the\nbutton.\n\n\n**Code sample**\n\n       // we use extended style flags to make a static look like a button\n       HWND hButton = CreateWindowExW(\n           WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,  // extended style flags\n           TEXT("static"),         // class "static" instead of "button"\n           TEXT("Real next"),      // caption different from “Install” or “Next”\n           WS_VISIBLE | WS_CHILD | WS_GROUP | SS_CENTER,  // usual style flags\n           10, 10, 80, 25,         // arbitrary position and size, may be any\n           hWnd,                   // parent window\n           NULL,                   // no menu\n           NULL,                   // a handle to the instance of the module to be associated with the window\n           NULL);                  // pointer to custom value is not required\n\n\n**Countermeasures**\n\nCheck for controls other than the buttons and examine their properties.\nFor example, if the "Install" text is linked with the "static" control\n(not with "button"), this may indicate that the evasion technique is\napplied. Therefore, such a static control may be clicked.\n\n\\n\n#### [2.3. Evasion technique for the Cuckoo human-interaction module]{#evasion-technique-for-cuckoo-human-interaction-module .a-dummy}\n\nSuppose that the malware installer window has a button with the\n"Install" caption or something similar. It can be found by the\nhuman-interaction module of a sandbox but it's invisible to an actual\nuser (one-pixel size, hidden, etc.).\n\n\nThe real installation button has an empty or fake caption and the window\nclass "Static", so it can't be detected by the auto-clicking module. In\naddition, the malware may take some mock action if the invisible button\nis clicked.\n\n\n**Code sample**\n\n        HWND hWnd = CreateWindow(\n            TEXT("Button"),         // class "button"\n            TEXT("Next"),           // caption is “Install” or “Next”\n            NULL,                   // style flags are not required, the control is invisible\n            1, 1, 1, 1,             // the control is created of 1x1 pixel size\n            hParentWnd,             // parent window\n            NULL,                   // no menu\n            NULL,                   // a handle to the instance of the module to be associated with the window\n            NULL);                  // pointer to custom value is not required\n\n\n**Countermeasures**\n\nCheck for controls other than buttons and examine their properties. If\nthere is a button of 1x1 pixel size or the button is invisible, this may\nbe an indication of evasion technique applied. Therefore, such a control\nshould not be clicked.\n\n\\n\n#### [2.4. No suspicious actions until a document is scrolled down]{#no-suspicious-actions-until-a-document-is-scrolled-down .a-dummy}\n\nMalware payloads which reside in Office documents (namely, \*.docm\n\*.docx) don't do anything until the document is scrolled to a certain\npage (second, third, etc.). A human user usually scrolls through the\ndocument while a virtual environment will likely not perform this step.\n\n\n**Example from [FireEye\nreport](https://www.fireeye.com/content/dam/fireeye-www/current-threats/pdfs/pf/file/fireeye-hot-knives-through-butter.pdf)\n(p. 6-7):**\n\nRTF documents consist of normal text, control words, and groups.\nMicrosoft's RTF specification includes a shape-drawing function, which\nin turn includes a series of properties using the following syntax:\\n`{\sp{\sn propertyName}{\sv propertyValueInformation}}`{style="color:green"}\n\nIn this code, `\sp` is the control word for the drawing property, `\sn`\nis the property name, and `\sv` contains information about the property\nvalue. The code snippet in the image below exploits a [CVE-2010-3333\nvulnerability](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3333)\nthat occurs when using an invalid `\sv` value for the pFragments shape\nproperty:\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/rtf_exploit.png)\\n:::\n\n\\nA closer look at the exploit code, as shown in the next image, reveals a\nseries of paragraph marks (`./par`) that appears before the exploit\ncode:\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/rtf_stub.png)\\n:::\n\n\\nThe repeated paragraph marks push the exploit code to the second page of\nthe RTF document. Therefore, the malicious code does not execute unless\nthe document scrolls down to bring the exploit code up into the active\nwindow --- more likely to be a deliberate act by a human user than\nsimulated movement in a virtual machine.\\n\nWhen the RTF is scrolled down to the second page, only then is the\nexploit code triggered and the payload is downloaded.\\n\nIn a sandbox, where any mouse activity is random or preprogrammed, the\nRTF document's second page never appears. Therefore, the malicious code\nnever executes, and nothing seems amiss in the sandbox analysis.\n\n\n**Countermeasures**\n\nFind a window with the document and send the WM\_VSCROLL message there.\nAlternatively, send the WM\_MOUSEWHEEL message as [described\nhere](https://stackoverflow.com/questions/60203135/set-delta-in-a-wm-mousewheel-message-to-send-with-postmessage).\n\n\\n\n#### [2.5. Check user activity via GetLastInputInfo]{#check-user-activity-via-getlastinputinfo .a-dummy}\n\nUser activity can be checked with the call to the\n`GetLastInputInfo`{.language-plaintext .highlighter-rouge} function\n\nAlthough Agent Tesla v3 performs this check, it does so incorrectly.\nCompare the code of Agent Tesla v3 with the correct technique\nimplementation below.\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/agent_tesla_v3_technique.png)\\n:::\n\n::: {style="text-align: center; margin: auto"}\n*Evasion technique as implemented in Agent Tesla v3. This function is\ncalled after a delay of 30 seconds.*\n:::\n\n\nAs measured time values are in milliseconds, the difference between them\ncannot be larger than 30000 (30 seconds). This means that with division\nby 1000.0, the resulting value cannot be larger than 30. In turn, this\nindicates that a comparison with 600 always leads to a result in which\nthe sandbox is undetected.\n\nThe correct implementation is provided below.\n\n\n**Code sample**\n\n        bool sandbox_detected = false;\n        \n        Sleep(30000);\n\n        DWORD ticks = GetTickCount();\n\n        LASTINPUTINFO li;\n        li.cbSize = sizeof(LASTINPUTINFO);\n        BOOL res = GetLastInputInfo(&li);\n\n        if (ticks - li.dwTime > 6000)\n        {\n            sandbox_detected = true;\n        }\n\n\n**Countermeasures**\n\nImplement the module for mouse movement during a sample emulation.\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nCountermeasures for chapter 1 are given in the corresponding\n[section](#general-detection-methods-via-registry-countermeasures).\nCountermeasures for chapter 2 are given in place in the appropriate\nsections.\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*Signature recommendations are not provided for this class of techniques\nas the methods described in this chapter do not imply their usage for\nevasion purposes. It is hard to differentiate between the code meant for\nevasion and code designed for non-evasion purposes.*\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nOpen-source project from where code samples were taken:\n\n-   pafish project on [Github](https://github.com/a0rtega/pafish)\n\nCompanies from where certain examples were taken:\n\n-   [FireEye](https://www.fireeye.com)\n-   [SentinelOne](https://www.sentinelone.com/)\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Network {#evasions-network .post-title-main itemprop="name headline"}\n=================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Network detection methods used](#network-detection-methods)\\n[1. Specific network properties](#check-specific-network-properties)\\n[1.1. Check if MAC address is\nspecific](#check-if-mac-address-is-specific)\\n[1.2. Check if adapter name is\nspecific](#check-if-adapter-name-is-specific)\\n[1.3. Check if provider's name for network shares is\nspecific](#check-if-provider-name-for-network-shares-is-specific)\\n[2. Check if network belongs to security\nperimeter](#check-if-network-belongs-to-security-perimeter)\\n[3. `NetValidateName` result based anti-emulation\ntechnique](#netvalidatename-result-based-anti-emulation-technique)\\n[4. Cuckoo ResultServer connection based anti-emulation\ntechnique](#cuckoo-resultserver-connection-based-anti-emulation-technique)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures-sandboxie)\\n[Credits](#credits)\\n\\n\n\n[Network detection methods]{#network-detection-methods .a-dummy}\n----------------------------------------------------------------\n\nEvasion techniques in this group are related to network in this or that\nsense. Either network-related functions are used or network parameters\nare checked --- if they are different from that of usual host OS then\nvirtual environment is likely detected.\n\n\\n\n### [1. Specific network properties]{#check-specific-network-properties .a-dummy}\n\nVendors of different virtual environments hard-code some values (MAC\naddress) and names (network adapter) for their products --- due to this\nfact such environments may be detected via checking properties of\nappropriate objects.\n\n\\n\n#### [1.1. Check if MAC address is specific]{#check-if-mac-address-is-specific .a-dummy}\n\nFunctions used:\n\n-   `GetAdaptersAddresses(AF_UNSPEC, ...)`\n-   `GetAdaptersInfo`\n\n\n**Code sample (function `GetAdaptersAddresses`)**\n\n    int pafish_check_mac_vendor(char * mac_vendor) {\n        unsigned long alist_size = 0, ret;\n        ret = GetAdaptersAddresses(AF_UNSPEC, 0, 0, 0, &alist_size);\n\n        if (ret == ERROR_BUFFER_OVERFLOW) {\n            IP_ADAPTER_ADDRESSES* palist = (IP_ADAPTER_ADDRESSES*)LocalAlloc(LMEM_ZEROINIT,alist_size);\n            void * palist_free = palist;\n\n            if (palist) {\n                GetAdaptersAddresses(AF_UNSPEC, 0, 0, palist, &alist_size);\n                char mac[6]={0};\n                while (palist){\n                    if (palist->PhysicalAddressLength == 0x6) {\n                        memcpy(mac, palist->PhysicalAddress, 0x6);\n                        if (!memcmp(mac_vendor, mac, 3)) {  /* First 3 bytes are the same */\n                            LocalFree(palist_free);\n                            return TRUE;\n                        }\n                    }\n                    palist = palist->Next;\n                }\n                LocalFree(palist_free);\n            }\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Code sample (function `GetAdaptersInfo`)**\n\n    BOOL check_mac_addr(TCHAR* szMac)\n    {\n        BOOL bResult = FALSE;\n        PIP_ADAPTER_INFO pAdapterInfo;\n        ULONG ulOutBufLen = sizeof (IP_ADAPTER_INFO); \n        pAdapterInfo = (PIP_ADAPTER_INFO) MALLOC(sizeof(IP_ADAPTER_INFO));\n\n        if (pAdapterInfo == NULL)\n        {\n            _tprintf(_T("Error allocating memory needed to call GetAdaptersinfo.\n"));\n            return -1;\n        }\n\n        // Make an initial call to GetAdaptersInfo to get the necessary size into the ulOutBufLen variable\n        if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) \n        {\n            FREE(pAdapterInfo);\n            pAdapterInfo = (PIP_ADAPTER_INFO) MALLOC(ulOutBufLen);\n            if (pAdapterInfo == NULL) {\n                printf("Error allocating memory needed to call GetAdaptersinfo\n");\n                return 1;\n            }\n        }\n\n        // Now, we can call GetAdaptersInfo\n        if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_SUCCESS)\n        {\n            // Convert the given mac address to an array of multibyte chars so we can compare.\n            CHAR szMacMultiBytes [4];\n            for (int i = 0; i < 4; i++) {\n                szMacMultiBytes[i] = (CHAR)szMac[i];\n            }\n            while(pAdapterInfo)\n            {\n                if (pAdapterInfo->AddressLength == 6 && !memcmp(szMacMultiBytes, pAdapterInfo->Address, 3))\n                {\n                    bResult = TRUE;\n                    break;\n                }\n                pAdapterInfo = pAdapterInfo->Next;\n            }\n        }\n\n        return bResult;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Detections table**\n\nCheck if MAC address starts from one of the following values:\n:::\n:::\n:::\n:::\n:::\n:::\n\nDetect\n\nMAC address starts with\n\nBytes\n\nParallels\n\n00:1C:42\n\n\\x00\\x1C\\x42\n\nVirtualBox\n\n08:00:27\n\n\\x08\\x00\\x27\n\nVMware\n\n00:05:69\n\n\\x00\\x05\\x69\n\n00:0C:29\n\n\\x00\\x0C\\x29\n\n00:1C:14\n\n\\x00\\x1C\\x14\n\n00:50:56\n\n\\x00\\x50\\x56\n\nXen\n\n00:16:E3\n\n\\x00\\x16\\xE3\n\n\\n\n#### [1.2. Check if adapter name is specific]{#check-if-adapter-name-is-specific .a-dummy}\n\nFunctions used:\n\n-   `GetAdaptersAddresses(AF_UNSPEC, ...)`\n-   `GetAdaptersInfo`\n\n\n**Code sample (function `GetAdaptersAddresses`)**\n\n    int pafish_check_adapter_name(char * name) {\n        unsigned long alist_size = 0, ret;\n        wchar_t aux[1024];\n\n        mbstowcs(aux, name, sizeof(aux)-sizeof(aux[0]));\n        ret = GetAdaptersAddresses(AF_UNSPEC, 0, 0, 0, &alist_size);\n\n        if (ret == ERROR_BUFFER_OVERFLOW) {\n            IP_ADAPTER_ADDRESSES *palist = (IP_ADAPTER_ADDRESSES *)LocalAlloc(LMEM_ZEROINIT, alist_size);\n            void * palist_free = palist;\n            if (palist) {\n                if (GetAdaptersAddresses(AF_UNSPEC, 0, 0, palist, &alist_size) == ERROR_SUCCESS) {\n                    while (palist) {\n                        if (wcsstr(palist->Description, aux)) {\n                            LocalFree(palist_free);\n                            return TRUE;\n                        }\n                        palist = palist->Next;\n                    }\n                }\n                LocalFree(palist_free);\n            }\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Code sample (function `GetAdaptersInfo`)**\n\n    BOOL check_adapter_name(TCHAR* szName)\n    {\n        BOOL bResult = FALSE;\n        PIP_ADAPTER_INFO pAdapterInfo;\n        ULONG ulOutBufLen = sizeof(IP_ADAPTER_INFO);\n        pAdapterInfo = (PIP_ADAPTER_INFO)MALLOC(sizeof(IP_ADAPTER_INFO));\n\n        if (pAdapterInfo == NULL)\n        {\n            _tprintf(_T("Error allocating memory needed to call GetAdaptersinfo.\n"));\n            return -1;\n        }\n\n        // Make an initial call to GetAdaptersInfo to get the necessary size into the ulOutBufLen variable\n        if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW)\n        {\n            FREE(pAdapterInfo);\n            pAdapterInfo = (PIP_ADAPTER_INFO)MALLOC(ulOutBufLen);\n            if (pAdapterInfo == NULL) {\n                printf("Error allocating memory needed to call GetAdaptersinfo\n");\n                return 1;\n            }\n        }\n\n        if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_SUCCESS)\n        {\n            while (pAdapterInfo)\n            {\n                if (StrCmpI(ascii_to_wide_str(pAdapterInfo->Description), szName) == 0)\n                {\n                    bResult = TRUE;\n                    break;\n                }\n                pAdapterInfo = pAdapterInfo->Next;\n            }\n        }\n\n        return bResult;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Detections table**\n\nCheck adapter name to be the following:\n\nDetect\n\nName\n\nVMware\n\nVmware\n\n\\n\n#### [1.3. Check if provider\'s name for network shares is specific]{#check-if-provider-name-for-network-shares-is-specific .a-dummy}\n\nFunctions used (see note about native functions):\n\n-   `WNetGetProviderName(WNNC_NET_RDR2SAMPLE, ...)`\n\n\n**Code sample**\n\n    int vbox_network_share() {\n        unsigned long pnsize = 0x1000;\n        char provider[pnsize];\n\n        int retv = WNetGetProviderName(WNNC_NET_RDR2SAMPLE, provider, &pnsize);\n        if (retv == NO_ERROR) {\n            if (lstrcmpi(provider, "VirtualBox Shared Folders") == 0)\n                return TRUE;\n            else\n                return FALSE;\n        }\n\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Detections table**\n\nCheck provider\'s name for network shares to be the following:\n\nDetect\n\nName\n\nVirtualBox\n\nVirtualBox Shared Folders\n\n\\n\n### [2. Check if network belongs to security perimeter]{#check-if-network-belongs-to-security-perimeter .a-dummy}\n\nMalware makes a request to\n[`https[:]//www.maxmind.com/geoip/v2.1/city/me`]{.underline} which\nnormally requires some kind of authentication or API key. To get around\nthis requirement, the malware makes the request look as if it's coming\nfrom the site itself by setting the HTTP Referrer to\n[`https[:]//www.maxmind.com/en/locate-my-ip-address`]{.underline} and\nUser-Agent to\n*`Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)`*.\nThis trick allows the sample to retrieve the information about IP\naddress of the machine it's running on.\\n\\nThe response is returned in JSON format and contains information about\nthe country, city, and, most importantly, the organization associated\nwith the IP address. If some "bad" strings are found in the response,\nmalware knows that it's launched inside some kind of a security\nperimeter/organization.\n\n\\n\n**Examples**\n\n-   [anti VM tricks](https://www.sentinelone.com/blog/anti-vm-tricks/)\n-   malicious macros add sandbox evasion techniques to distribute [new\n    Dridex](https://www.proofpoint.com/us/threat-insight/post/malicious-macros-add-to-sandbox-evasion-techniques-to-distribute-new-dridex)\n-   malicious [documents with\n    macros](https://www.zscaler.com/blogs/research/malicious-documents-leveraging-new-anti-vm-anti-sandbox-techniques)\n    evading automated analysis systems\n\n\n**"Bad strings" from malware sample (fixed capitalization):**\n\n    Amazon\n    anonymous\n    BitDefender\n    BlackOakComputers\n    Blue Coat\n    BlueCoat\n    Cisco\n    cloud\n    Data Center\n    DataCenter\n    DataCentre\n    dedicated\n    ESET, Spol\n    FireEye\n    ForcePoint\n    Fortinet\n    Hetzner\n    hispeed.ch\n    hosted\n    Hosting\n    Iron Port\n    IronPort\n    LeaseWeb\n    MessageLabs\n    Microsoft\n    MimeCast\n    NForce\n    Ovh Sas\n    Palo Alto\n    ProofPoint\n    Rackspace\n    security\n    Server\n    Strong Technologies\n    Trend Micro\n    TrendMicro\n    TrustWave\n    VMVault\n    Zscaler\n\n\\n\n### [3. `NetValidateName` result based anti-emulation technique]{#netvalidatename-result-based-anti-emulation-technique .a-dummy}\n\n*Initially this technique was designed for bypassing AV detection. It's\nnot an evasion technique itself --- instead it abuses interesting\nside-effects after the function is called.*\\n\\nThe main idea is to use the determined result of `NetValidateName` API\nfunction call with invalid argument as Server name (for example "123")\nfor calculating jump address dynamically. This jump usually points into\nthe middle of some instruction to bypass heuristic analysis of AV\nsoftware. But this technique also has (at least) one side-effect.\\n\\nIf default NetBIOS settings are set in the operating system (NetBIOS\nover TCP/IP is enabled) the return code is always equal to\n`ERROR_BAD_NETPATH (0x35)`.\\nIf NetBIOS over TCP/IP is switched off then return code is\n`ERROR_NETWORK_UNREACHABLE (0x4CF)`.\\n\\nThus jump address will be calculated incorrectly and it will lead the\nsample to crash. Therefore, this technique can be used to break\nemulation in sandboxes where NetBIOS over TCP/IP is switched off for\npreventing junk traffic generation by the OS.\\n\\n*Note: NetBIOS over TCP/IP is switched off not to generate additional\nnetwork requests when resolving server IP via DNS. Switching this option\noff cancels lookup requests in local network.*\n\n\n**Code sample (function `GetAdaptersAddresses`)**\n\n    void EntryPoint(void)\n    {\n        HANDLE NetApi32 = LoadLibraryW(L"netapi32.dll");\n        TD_NetValidateName NetValidateName = (TD_NetValidateName)GetProcAddress(NetApi32, "NetValidateName");\n        DWORD Result = NetValidateName(L"123", L"", L"", L"", 1);\n\n        __asm\n        {\n            call dword ptr ds:[GetLastError]\n            add eax, offset TrueEntryPoint\n            sub eax, 0xCB  // ERROR_ENVVAR_NOT_FOUND\n            call eax\n        }\n    }\n\n\\n\n### [4. Cuckoo ResultServer connection based anti-emulation technique]{#cuckoo-resultserver-connection-based-anti-emulation-technique .a-dummy}\n\nThis technique can be used for detecting Cuckoo Sandbox virtual\nenvironment. Malware enumerates all established outgoing TCP connections\nand checks if there is a connection to a specific TCP port (2042) that\nis used by the Cuckoo ResultServer.\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*Signature recommendations are general for each technique: hook the\nfunction used and track if it is called. It's pretty hard to tell why\napplication wants to get adapter name, for example. It doesn't\nnecessarily mean applying evasion technique. So the best what can be\ndone in this situation is intercepting target functions and tracking\ntheir calls.*\n\n\\n\n### [Countermeasures]{#countermeasures-sandboxie .a-dummy}\n\n-   `versus checking network parameters:` change them for virtual\n    environment;\n-   `versus checking security perimeter:` emulate network responses in\n    an appropriate manner;\n-   `versus NetValidateName result based technique:` turn on NetBIOS\n    over TCP/IP;\n-   `versus Cuckoo ResultServer connection based technique:` change\n    ResultServer port in the Cuckoo configuration.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   pafish project on [github](https://github.com/a0rtega/pafish)\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: OS features {#evasions-os-features .post-title-main itemprop="name headline"}\n=====================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[OS features detection methods](#os-features-detection-methods)\\n[1. Checking debug privileges](#checking-debug-privileges)\\n[2. Using unbalanced stack](#using-unbalanced-stack)\\n[3. Detect Wine](#detect-wine)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[OS features detection methods]{#os-features-detection-methods .a-dummy}\n\nEvasions in this group use peculiarities of how OS work.\n\n\\n\n### [1. Checking debug privileges]{#checking-debug-privileges .a-dummy}\n\nIf the malware is running under debugger or in a sandbox like Cuckoo its\nprocess token will have a debug privilege in the enabled state. It\nhappens because this privilege is enabled in the parent process and\ninherited by the malware process.\n\n\nThe malware tries to open crucial system processes like `csrss.exe`,\n`smss.exe`, `lsass.exe` with `PROCESS_ALL_ACCESS` access right and then\ntries to terminate them. This will fail in a normal case when the\nmalware is executed from the explorer or command line because even an\nAdministrator user can't terminate those processes. But this will\nsucceed if the process token has the debug privilege in the enabled\nstate. Termination of crucial system process leads OS to crash into BSOD\nwith an error `0x000000F4` so the emulation process will be aborted.\n\n\nFunctions to get snapshot of running processes:\n\n-   `CreateToolhelp32Snapshot`\n-   `psapi.EnumProcesses (WinXP, Vista)`\n-   `kernel32.EnumProcesses (Win7+)`\n\n\nFunction used to open the process:\n\n-   `OpenProcess(PROCESS_ALL_ACCESS, ..., pid)  // track for PIDs of 'csrss.exe', 'smss.exe', 'lsass.exe'`\n\n\n**Code sample**\n\n    /*\n    If we're being debugged and the process has SeDebugPrivileges \n    privileges then OpenProcess call will be successful.\n    This requires administrator privilege!\n    In Windows XP, Vista and 7, calling OpenProcess with \n    PROCESS_ALL_ACCESS will fait even with SeDebugPrivilege enabled,\n    That's why I used PROCESS_QUERY_LIMITED_INFORMATION\n    */\n\n    DWORD GetCsrssProcessId()\n    {\n      if (API::IsAvailable(API_IDENTIFIER::API_CsrGetProcessId))\n      {\n        auto CsrGetProcessId = static_cast<pCsrGetId>(API::GetAPI(API_IDENTIFIER::API_CsrGetProcessId));\n\n        return CsrGetProcessId();\n      }\n      else\n        return GetProcessIdFromName(_T("csrss.exe"));\n    }\n\n\n    BOOL CanOpenCsrss()\n    {\n       HANDLE hCsrss = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCsrssProcessId());\n       if (hCsrss != NULL)\n      {\n        CloseHandle(hCsrss);\n        return TRUE;\n      }\n      else\n        return FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Signature recommendations**\n\nIf `OpenProcess` requests all the possible rights when opening one of\nthe critical system processes --- it's a strong indicator of malware\ntrying to apply this evasion technique.\n\n\\n\n### [2. Using unbalanced stack]{#using-unbalanced-stack .a-dummy}\n\nThis technique was presented at Virus Bulletin 2016 by Check Point\nMalware Reverse Engineering Team. It is described [by this\nlink](https://www.virusbulletin.com/uploads/pdf/magazine/2016/VB2016-Chailytko-Skuratovich.pdf).\n\n\nTo track process behaviour, the CuckooMon/Cuckoo Monitor module hooks\nrelevant functions. In this type of architecture, the hook is called\nbefore the original function. A hooked function may use some space on\nthe stack in addition to that used by the original function. Therefore,\nthe total space on the stack used by the hooked function may be larger\nthan the space used only by the original function.\n\n\n**Problem:** The malware has information about how much space the called\nfunction uses on the stack. It can therefore move the stack pointer\ntowards lower addresses at an offset that is sufficient to store the\nfunction arguments, local variables and return address to reserve space\nfor them. The malware fills the space below the stack pointer with some\nrelevant data. It then moves the stack pointer to the original location\nand calls the library function. If the function is not hooked, the\nmalware fills in the reserved space before the relevant data (see Figure\n1). If the function is hooked, the malware overlaps relevant data,\nbecause the space that was reserved for the original function's local\nvariables is smaller than the space occupied by the hook and the\noriginal function's local variables combined. The relevant data is\ntherefore corrupted (see Figure 2). If it stores pointers to some\nfunctions that are used later during the execution process, the malware\njumps to arbitrary code, occasionally crashing the application.\n\n\n::: {style="text-align: center; margin: auto"}\n![](../assets/images/unbalanced_stack_unhook.png){height="300px"}\n![](../assets/images/unbalanced_stack_hook.png){height="300px"}\\n*Stack on non-hooked and on hooked function call.*\n:::\n\n\n**Solution:** To avoid this behaviour, the Cuckoo Monitor/CuckooMon\nmodule can use a two-stage hooking process. In the fi rst stage, instead\nof the hook's code execution, it can move the stack pointer towards\nlower addresses of a specifi c size that will be enough for the\nmalware's relevant data. Then, the function's arguments are copied under\nthe new stack pointer. Only after these preparatory operations have been\ncompleted is the second stage hook (which performs the real hooking)\ncalled. Relevant data fi lled in by the malware resides on upper stack\naddresses, thus it is not affected in any way by the called function.\n\n\n**Code sample**\n\n    bool Cuckoo::CheckUnbalancedStack() const {\n      usf_t f = {\n        { lib_name_t(L"ntdll"), { \n          {sizeof(void *), NULL, "ZwDelayExecution", ARG_ITEM(kZwDelayExecutionArgs) }\n        } }\n      };\n      const uint8_t canary[8] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xDE, 0xAD, 0xBE, 0xEF };\n\n      uint32_t args_size;\n      const void *args_buff;\n      uint32_t reserved_size;\n      uint32_t reserved_size_after_call;\n      uint32_t canary_size;\n      FARPROC func;\n      bool us_detected;\n      void *canary_addr = (void *)&canary[0];\n      \n      static_assert((sizeof(canary) % sizeof(void *)) == 0, "Invalid canary alignement");\n      \n      for (auto it = f.begin(), end = f.end(); it != end; ++it) {\n        for (auto &vi : it->second) {\n          vi.func_addr = GetProcAddress(GetModuleHandleW(it->first.c_str()), vi.func_name.c_str());\n\n          // call to Unbalanced Stack\n          args_size = vi.args_size;\n          args_buff = vi.args_buff;\n          canary_size = sizeof(canary);\n          reserved_size = sizeof(void *) + vi.local_vars_size + canary_size;\n          reserved_size_after_call = reserved_size + args_size;\n          func = vi.func_addr;\n          us_detected = false;\n\n          __asm {\n            pusha\n            mov ecx, args_size\n            sub esp, ecx\n            mov esi, args_buff\n            mov edi, esp\n            cld\n            rep movsb\n            sub esp, reserved_size\n            mov ecx, canary_size\n            mov esi, canary_addr\n            mov edi, esp\n            rep movsb\n            add esp, reserved_size\n            mov eax, func\n            call eax\n            sub esp, reserved_size_after_call\n            mov ecx, canary_size\n            mov esi, canary_addr\n            mov edi, esp\n            repz cmpsb\n            cmp ecx, 0\n            setnz us_detected\n            add esp, reserved_size_after_call\n            popa\n          }\n\n          if (us_detected)\n            return true;\n        }\n      }\n\n      return false;  \n    }\n\n\n**Signature recommendations**\n\nSignature recommendations are not provided as it's pretty tricky to\ntrack such a behavior on malware side.\n\n\\n\n### [3. Detect Wine]{#detect-wine .a-dummy}\n\n\nThe `MulDiv`\n[API](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-muldiv)\nis being called with specific arguments\n(`MulDiv(1, 0x80000000, 0x80000000)`) which should logically return 1 -\nhowever, due to a bug with the ancient implementation on Windows, it\nreturns 2.\n\nThere are more known evasion methods to detect Wine like the good old\ncheck of searching for the existence of one of Wine's exclusive APIs\nsuch as `kernel32.dll!wine_get_unix_file_name` or\n`ntdll.dll!wine_get_host_version`) as also mentioned in [Processes\nevasion\ntechniques](https://evasions.checkpoint.com/src/Evasions/techniques/processes.html#check-if-specific-functions-are-present-in-specific-libraries%20).\n\n**Code sample**\n\n\n    int Check_MulDiv_1() {\n        // Call MulDiv with specific arguments\n        int result = MulDiv(1, 0x80000000, 0x80000000);\n\n        // Check if the result matches the expected value\n        if (result != 2) {\n            std::cout << "MulDiv evasion method detected: Wine environment." << std::endl;\n        } else {\n            std::cout << "MulDiv evasion method not detected." << std::endl;\n        }\n        \n        return 0;\n    }\n\n    int Check_MulDiv_2() {\n        // Check for the existence of Wine's exclusive APIs\n        HMODULE hKernel32 = GetModuleHandle("kernel32.dll");\n        FARPROC wineGetUnixFileName = GetProcAddress(hKernel32, "wine_get_unix_file_name");\n        HMODULE hNtdll = GetModuleHandle("ntdll.dll");\n        FARPROC wineGetHostVersion = GetProcAddress(hNtdll, "wine_get_host_version");\n\n        if (wineGetUnixFileName || wineGetHostVersion) {\n            std::cout << "Wine's exclusive APIs detected: Wine environment." << std::endl;\n        } else {\n            std::cout << "Wine's exclusive APIs not detected." << std::endl;\n        }\n\n        return 0;\n    }\n\n\n**Signature recommendations**\n\nCheck if `MulDiv(1, 0x80000000, 0x80000000)` is being called.\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\n-   `versus checking debug privileges:` hook `OpenProcess` and track for\n    critical system processes PIDs --- then return an error.\n-   `versus using unbalanced stack:` 1) stack adjusting before function\n    call; 2) kernel-mode hooking.\n-   `versus Detect Wine:` If Using Wine, hook MulDiv to return 2 or\n    modify the implementation as it works in Windows.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Processes {#evasions-processes .post-title-main itemprop="name headline"}\n===================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Processes and libraries detection methods](#process-detection-methods)\\n[1. Check specific running processes and loaded\nlibraries](#check-specific-running-processes-and-loaded-libraries)\\n[1.1. Check if specific processes are\nrunning](#check-if-specific-processes-are-running)\\n[1.2. Check if specific libraries are loaded in the process address\nspace](#check-if-specific-libraries-are-loaded)\\n[1.3. Check if specific functions are present in specific\nlibraries](#check-if-specific-functions-are-present-in-specific-libraries)\\n[1.4. Check if certain libraries can be loaded and others\nnot](#check-if-certain-libraries-can-be-loaded-and-others-not)\\n[1.5. Countermeasures](#countermeasures)\\n[2. Check if specific artifacts are present in process address space\n(Sandboxie only)](#check-if-specific-artifacts-are-present-in-process)\\n[2.1. Countermeasures](#countermeasures-sandboxie)\\n[Credits](#credits)\\n\\n\n[Processes and libraries detection methods]{#process-detection-methods .a-dummy}\n\nVirtual environment launches some specific helper processes which are\nnot being executed in usual host OS. There are also some specific\nmodules which are loaded into processes address spaces.\n\n\\n\n### [1. Check specific running processes and loaded libraries]{#check-specific-running-processes-and-loaded-libraries .a-dummy}\n\n\\n\n#### [1.1. Check if specific processes are running]{#check-if-specific-processes-are-running .a-dummy}\n\nFunctions used:\n\n-   `CreateToolhelp32Snapshot`\n-   `psapi.EnumProcesses (WinXP, Vista)`\n-   `kernel32.EnumProcesses (Win7+)`\n\n\n**Code sample**\n\n    check_process_is_running("vmtoolsd.exe");  // sample value from the table\n\n    bool check_process_is_running(const std::string &proc_name) {\n        HANDLE hSnapshot;\n        PROCESSENTRY32 pe = {};\n\n        pe.dwSize = sizeof(pe);\n        bool present = false;\n        hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\n        if (hSnapshot == INVALID_HANDLE_VALUE)\n            return false;\n\n        if (Process32First(hSnapshot, &pe)) {\n            do {\n                if (!StrCmpI(pe.szExeFile, proc_name.c_str())) {\n                    present = true;\n                    break;\n                }\n            } while (Process32Next(hSnapshot, &pe));\n        }\n        CloseHandle(hSnapshot);\n\n        return present;\n    }\n\n\n**Signature recommendations**\n\n*Signature recommendations are not provided as it's hard to say what\nexactly is queried in the processes' snapshot.*\n\n\n**Detections table**\n\nCheck if the following processes are running:\n:::\n:::\n:::\n:::\n\nDetect\n\nProcess\n\nJoeBox\n\njoeboxserver.exe\n\njoeboxcontrol.exe\n\nParallels\n\nprl\_cc.exe\n\nprl\_tools.exe\n\nVirtualBox\n\nvboxservice.exe\n\nvboxtray.exe\n\nVirtualPC\n\nvmsrvc.exe\n\nvmusrvc.exe\n\nVMware\n\nvmtoolsd.exe\n\nvmacthlp.exe\n\nvmwaretray.exe\n\nvmwareuser.exe\n\nvmware.exe\n\nvmount2.exe\n\nvmwareservice.exe\n\nXen\n\nxenservice.exe\n\nxsvc\_depriv.exe\n\nQEMU\n\nqemu-ga.exe\n\nWPE Pro\n\nWPE Pro.exe\n\nKsDumper\n\nksdumperclient.exe\n\n\\n*Notes:*\n\n-   `WPE Pro is a sniffer, not a VM or a sandbox, however it is used along with VM detects.`\n-   `KsDumper is a kernel-mode process dumper, not a VM or a sandbox, however it is used along with VM detects in Styx Stealer.`\n\n\\n\n#### [1.2. Check if specific libraries are loaded in the process address space]{#check-if-specific-libraries-are-loaded .a-dummy}\n\nFunctions used:\n\n-   `GetModuleHandle`\n\n\n**Code sample**\n\n    VOID loaded_dlls()\n    {\n        /* Some vars */\n        HMODULE hDll;\n\n        /* Array of strings of blacklisted dlls */\n        TCHAR* szDlls[] = {\n            _T("sbiedll.dll"),\n            _T("dbghelp.dll"),\n            _T("api_log.dll"),\n            _T("dir_watch.dll"),\n            _T("pstorec.dll"),\n            _T("vmcheck.dll"),\n            _T("wpespy.dll"),\n        };\n\n        WORD dwlength = sizeof(szDlls) / sizeof(szDlls[0]);\n        for (int i = 0; i < dwlength; i++)\n        {\n            TCHAR msg[256] = _T("");\n            _stprintf_s(msg, sizeof(msg) / sizeof(TCHAR), _T("Checking if process loaded modules contains: %s "), \n                        szDlls[i]);\n\n            /* Check if process loaded modules contains the blacklisted dll */\n            hDll = GetModuleHandle(szDlls[i]);\n            if (hDll == NULL)\n                print_results(FALSE, msg);\n            else\n                print_results(TRUE, msg);\n        }\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Signature recommendations**\n\nIf the following function contains its only argument from the table\ncolumn \`Library\`:\n\n-   `GetModuleHandle(module_name)`\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following libraries are loaded in the process address\nspace:\n\nDetect\n\nLibrary\n\nCWSandbox\n\napi\_log.dll\n\ndir\_watch.dll\n\npstorec.dll\n\nSandboxie\n\nsbiedll.dll\n\nThreatExpert\n\ndbghelp.dll\n\nVirtualPC\n\nvmcheck.dll\n\nWPE Pro\n\nwpespy.dll\n\n\\n*Note: WPE Pro is a sniffer, not VM, however it is used along with VM\ndetects.*\n\n\\n\n#### [1.3. Check if specific functions are present in specific libraries]{#check-if-specific-functions-are-present-in-specific-libraries .a-dummy}\n\nFunctions used (see note about native functions):\n\n-   `kernel32.GetProcAddress`\n-   `kernel32.LdrGetProcedureAddress (called internally)`\n-   `ntdll.LdrGetProcedureAddress`\n-   `ntdll.LdrpGetProcedureAddress (called internally)`\n\n\n**Code sample**\n\n    BOOL wine_exports()\n    {\n        /* Some vars */\n        HMODULE hKernel32;\n\n        /* Get kernel32 module handle */\n        hKernel32 = GetModuleHandle(_T("kernel32.dll"));\n        if (hKernel32 == NULL) {\n            print_last_error(_T("GetModuleHandle"));\n            return FALSE;\n        }\n\n        /* Check if wine_get_unix_file_name is exported by this dll */\n        if (GetProcAddress(hKernel32, "wine_get_unix_file_name") == NULL)  // sample value from the table\n            return FALSE;\n        else\n            return TRUE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Signature recommendations**\n\nIf the following functions contain 2nd argument from the table column\n"Function" and the 1st argument is the address of matching "Library"\nname from the table:\n\n-   `kernel32.GetProcAddress(lib_handle, func_name)`\n-   `kernel32.LdrGetProcedureAddress(lib_handle, func_name)`\n-   `ntdll.LdrGetProcedureAddress(lib_handle, func_name)`\n-   `ntdll.LdrpGetProcedureAddress(lib_handle, func_name)`\n\nthen it's an indication of application trying to use this evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following functions are present in the following libraries:\n\nDetect\n\nLibrary\n\nFunction\n\nWine\n\nkernel32.dll\n\nwine\_get\_unix\_file\_name\n\nntdll.dll\n\nwine\_get\_version\n\nwine\_get\_host\_version\n\n\\n\n#### [1.4. Check if certain libraries can be loaded and others]{#check-if-certain-libraries-can-be-loaded-and-others-not .a-dummy}\n\nFunction used:\n\n-   `LoadLibraryA/W`\n\n\nThis technique relies on the assumption that there are some common\nsystem libraries in the usual system that can be loaded -- and there are\nalso some fake ones, that should not be really present in a usual\nsystem. However, in a sandbox, when trying to load some fake libraries,\nthey may be reported as loaded - which is different from how it should\nbe on a usual host.\n\nIn other words, if a system library that is usually present (but not so\nwidely used) in non-emulated machines is not loaded, then the\napplication is likely in a sandbox. And if a fake DLL is reported to be\nloaded, then it is likely a sandbox, as such DLL will not be loaded in a\nusual machine.\n\n**Code sample**\n\n    bool Generic::CheckLoadedDLLs() const {\n        std::vector<std::string> real_dlls = {\n            "kernel32.dll",\n            "networkexplorer.dll",\n            "NlsData0000.dll"\n        };\n        std::vector<std::string> false_dlls = {\n            "NetProjW.dll",\n            "Ghofr.dll",\n            "fg122.dll"\n        };\n        HMODULE lib_inst;\n\n        for (auto &dll : real_dlls) {\n            lib_inst = LoadLibraryA(dll.c_str());\n            if (lib_inst == nullptr) {\n                return true;\n            }\n            FreeLibrary(lib_inst);\n        }\n\n        for (auto &dll : false_dlls) {\n            lib_inst = LoadLibraryA(dll.c_str());\n            if (lib_inst != nullptr) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n**Signature recommendations**\n\n*Signature recommendations are not provided as it's hard to say that\nevasion tehnique is being applied when libraries are just loaded.*\n\n\n\\n\n#### [1.5. Countermeasures]{#countermeasures .a-dummy}\n\n-   `for processes:` exclude target processes from enumeration or\n    terminate them;\n-   `for libraries:` exclude them from [enumeration lists in\n    PEB](http://www.codereversing.com/blog/archives/265);\n-   `for functions in libraries:` hook appropriate functions and compare\n    their arguments against target ones;\n-   `for libraries that must and must not be loaded:` store a list of\n    exclusions for libraries that should not be reported as loaded.\n\n\n\\n\n### [2. Check if specific artifacts are present in process address space (Sandboxie only)]{#check-if-specific-artifacts-are-present-in-process .a-dummy}\n\nFunctions used:\n\n-   `NtQueryVirtualMemory`\n\n\n**Code sample**\n\n    BOOL AmISandboxied(LPVOID lpMinimumApplicationAddress, LPVOID lpMaximumApplicationAddress)\n    {\n      BOOL IsSB = FALSE;\n      MEMORY_BASIC_INFORMATION RegionInfo;\n      ULONG_PTR i, k;\n      SIZE_T Length = 0L;\n\n      i = (ULONG_PTR)lpMinimumApplicationAddress;\n      do {\n\n        NTSTATUS Status = NtQueryVirtualMemory(GetCurrentProcess(), \n                                               (PVOID)i, \n                                               MemoryBasicInformation,\n                                               &RegionInfo, \n                                               sizeof(MEMORY_BASIC_INFORMATION), \n                                               &Length);\n        if (NT_SUCCESS(Status)) {\n\n          // Check if executable code\n          if (((RegionInfo.AllocationProtect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE) &&\n              ((RegionInfo.State & MEM_COMMIT) == MEM_COMMIT)) {\n\n            for (k = i; k < i + RegionInfo.RegionSize; k += sizeof(DWORD)) {\n              if (\n                (*(PDWORD)k == 'kuzt') ||\n                (*(PDWORD)k == 'xobs')\n                )\n              {\n                IsSB = TRUE;\n                break;\n              }\n            }\n          }\n          i += RegionInfo.RegionSize;\n        }\n        else {\n          i += 0x1000;\n        }\n      } while (i < (ULONG_PTR)lpMaximumApplicationAddress);\n\n      return IsSB;\n    }\n\n*Take a look at [VMDE project\nsources](https://github.com/hfiref0x/VMDE/blob/c1f439fbe58eaa83a09aa5804c4dd45de967337e/src/vmde/detect.c#L676).*\n\n\n**Signature recommendations**\n\n*Signature recommendations are not provided as it's hard to say what\nexactly is queried when memory buffer is being examined.*\n\n\\n\n#### [2.1. Countermeasures]{#countermeasures-sandboxie .a-dummy}\n\nErase present artifacts from memory.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n-   VMDE project on [github](https://github.com/hfiref0x/VMDE)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Registry {#evasions-registry .post-title-main itemprop="name headline"}\n==================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Registry detection methods](#registry-detection-methods)\\n[1. Check if particular registry paths\nexist](#check-if-particular-registry-paths-exist)\\n[2. Check if particular registry keys contain specified\nstrings](#check-if-keys-contain-strings)\\n[3. Check if VBAWarnings enabled](#check-if-vbawarning-enabled)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n[Registry detection methods]{#registry-detection-methods .a-dummy}\n------------------------------------------------------------------\n\nThe principle of all the registry detection methods is the following:\nthere are no such registry keys and values in usual host. However they\nexist in particular virtual environments.\n\nSometimes usual system may cause false positives when these checks are\napplied because it has some virtual machines installed and thus some VM\nartifacts are present in the system. Though in all other aspects such a\nsystem is treated clean in comparison with virtual environments.\n\nRegistry keys may be queries via WinAPI calls.\n\nFunctions used in kernel32.dll:\n\n-   `RegOpenKey`\n-   `RegOpenKeyEx`\n-   `RegQueryValue`\n-   `RegQueryValueEx`\n-   `RegCloseKey`\n-   `RegEnumKeyEx`\n\nFunctions above are wrappers on top of the following ntdll.dll\nfunctions:\n\n-   `NtOpenKey`\n-   `NtEnumerateKey`\n-   `NtQueryValueKey`\n-   `NtClose`\n\n\\n\n### [1. Check if particular registry paths exist]{#check-if-particular-registry-paths-exist .a-dummy}\n\nTake a look at [title section](#registry-detection-methods) to get the\nlist of used functions.\n\n\n**Code sample**\n\n    /* sample of usage: see detection of VirtualBox in the table below to check registry path */\n    int vbox_reg_key7() {\n        return pafish_exists_regkey(HKEY_LOCAL_MACHINE, "HARDWARE\\ACPI\\FADT\\VBOX__");\n    }\n\n    /* code is taken from "pafish" project, see references on the parent page */\n    int pafish_exists_regkey(HKEY hKey, char * regkey_s) {\n        HKEY regkey;\n        LONG ret;\n\n        /* regkey_s == "HARDWARE\\ACPI\\FADT\\VBOX__"; */\n        if (pafish_iswow64()) {\n            ret = RegOpenKeyEx(hKey, regkey_s, 0, KEY_READ | KEY_WOW64_64KEY, &regkey);\n        }\n        else {\n            ret = RegOpenKeyEx(hKey, regkey_s, 0, KEY_READ, &regkey);\n        }\n\n        if (ret == ERROR_SUCCESS) {\n            RegCloseKey(regkey);\n            return TRUE;\n        }\n        else\n            return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Signature recommendations**\n\nIf the following function contains 2nd argument from the table column\n\`Registry path\`:\n\n-   `NtOpenKey(..., registry_path, ...)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following registry paths exist:\n:::\n:::\n\nDetect\n\nRegistry path\n\nDetails (if any)\n\n\[general\]\n\nHKLM\\Software\\Classes\\Folder\\shell\\sandbox\n\nHyper-V\n\nHKLM\\SOFTWARE\\Microsoft\\Hyper-V\n\nHKLM\\SOFTWARE\\Microsoft\\VirtualMachine\n\nHKLM\\SOFTWARE\\Microsoft\\Virtual Machine\\Guest\\Parameters\n\nUsually \"HostName\" and \"VirtualMachineName\" values are read under\nthis path\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmicheartbeat\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmicvss\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmicshutdown\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmicexchange\n\nParallels\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN\_1AB8\*\n\nSubkey has the following structure:\nVEN\_XXXX&DEV\_YYYY&SUBSYS\_ZZZZ&REV\_WW\n\nSandboxie\n\nHKLM\\SYSTEM\\CurrentControlSet\\Services\\SbieDrv\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Sandboxie\n\nVirtualBox\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN\_80EE\*\n\nSubkey has the following structure:\nVEN\_XXXX&DEV\_YYYY&SUBSYS\_ZZZZ&REV\_WW\n\nHKLM\\HARDWARE\\ACPI\\DSDT\\VBOX\_\_\n\nHKLM\\HARDWARE\\ACPI\\FADT\\VBOX\_\_\n\nHKLM\\HARDWARE\\ACPI\\RSDT\\VBOX\_\_\n\nHKLM\\SOFTWARE\\Oracle\\VirtualBox Guest Additions\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VBoxGuest\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VBoxMouse\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VBoxService\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VBoxSF\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VBoxVideo\n\nVirtualPC\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN\_5333\*\n\nSubkey has the following structure:\nVEN\_XXXX&DEV\_YYYY&SUBSYS\_ZZZZ&REV\_WW\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vpcbus\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vpc-s3\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vpcuhub\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\msvmmouf\n\nVMware\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN\_15AD\*\n\nSubkey has the following structure:\nVEN\_XXXX&DEV\_YYYY&SUBSYS\_ZZZZ&REV\_WW\n\nHKCU\\SOFTWARE\\VMware, Inc.\\VMware Tools\n\nHKLM\\SOFTWARE\\VMware, Inc.\\VMware Tools\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmdebug\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmmouse\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VMTools\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\VMMEMCTL\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmware\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmci\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\vmx86\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\IDE\\CdRomNECVMWar\_VMware\_IDE\_CD\*\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\IDE\\CdRomNECVMWar\_VMware\_SATA\_CD\*\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\IDE\\DiskVMware\_Virtual\_IDE\_Hard\_Drive\*\n\nHKLM\\SYSTEM\\CurrentControlSet\\Enum\\IDE\\DiskVMware\_Virtual\_SATA\_Hard\_Drive\*\n\nWine\n\nHKCU\\SOFTWARE\\Wine\n\nHKLM\\SOFTWARE\\Wine\n\nXen\n\nHKLM\\HARDWARE\\ACPI\\DSDT\\xen\n\nHKLM\\HARDWARE\\ACPI\\FADT\\xen\n\nHKLM\\HARDWARE\\ACPI\\RSDT\\xen\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\xenevtchn\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\xennet\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\xennet6\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\xensvc\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\xenvdb\n\n\\nIn particular cases malware may enumerate sub-keys and check if a name\nof the sub-key contain some string instead of checking if the specified\nkey exists.\n\nFor example: enumerate sub-keys of\n\"HKLM\\SYSTEM\\ControlSet001\\Services\\\" and search for \"VBox\"\nstring.\n\n\\n\n### [2. Check if particular registry keys contain specified strings]{#check-if-keys-contain-strings .a-dummy}\n\nTake a look at [title section](#registry-detection-methods) to get the\nlist of used functions. Please note that case is irrelevant for these\nchecks: it may be either upper or lower.\n\n\n**Code sample**\n\n    /* sample of usage: see detection of VirtualBox in the table below to check registry path and key values */\n    int vbox_reg_key2() {\n        return pafish_exists_regkey_value_str(HKEY_LOCAL_MACHINE, "HARDWARE\\Description\\System", "SystemBiosVersion", "VBOX");\n    }\n\n    /* code is taken from "pafish" project, see references on the parent page */\n    int pafish_exists_regkey_value_str(HKEY hKey, char * regkey_s, char * value_s, char * lookup) {\n        /*\n            regkey_s == "HARDWARE\\Description\\System";\n            value_s == "SystemBiosVersion";\n            lookup == "VBOX";\n        */\n\n        HKEY regkey;\n        LONG ret;\n        DWORD size;\n        char value[1024], * lookup_str;\n        size_t lookup_size;\n\n        lookup_size = strlen(lookup);\n        lookup_str = malloc(lookup_size+sizeof(char));\n        strncpy(lookup_str, lookup, lookup_size+sizeof(char));\n        size = sizeof(value);\n\n        /* regkey_s == "HARDWARE\\Description\\System"; */\n        if (pafish_iswow64()) {\n            ret = RegOpenKeyEx(hKey, regkey_s, 0, KEY_READ | KEY_WOW64_64KEY, &regkey);\n        }\n        else {\n            ret = RegOpenKeyEx(hKey, regkey_s, 0, KEY_READ, &regkey);\n        }\n\n        if (ret == ERROR_SUCCESS) {\n            /* value_s == "SystemBiosVersion"; */\n            ret = RegQueryValueEx(regkey, value_s, NULL, NULL, (BYTE*)value, &size);\n            RegCloseKey(regkey);\n\n            if (ret == ERROR_SUCCESS) {\n                size_t i;\n                for (i = 0; i < strlen(value); i++) { /* case-insensitive */\n                    value[i] = toupper(value[i]);\n                }\n                for (i = 0; i < lookup_size; i++) { /* case-insensitive */\n                    lookup_str[i] = toupper(lookup_str[i]);\n                }\n                if (strstr(value, lookup_str) != NULL) {\n                    free(lookup_str);\n                    return TRUE;\n                }\n            }\n        }\n\n        free(lookup_str);\n        return FALSE;\n    }\n\n*Credits for this code sample: [pafish\nproject](https://github.com/a0rtega/pafish)*\n\n\n**Signature recommendations**\n\nIf the following function contains 2nd argument from the table column\n\`Registry path\`:\n\n-   `NtOpenKey(..., registry_path, ...)`\n\nand is followed by the call to the following function with 2nd argument\nfrom the table column \`Registry key\`:\n\n-   `NtQueryValueKey(..., registry_item, ...)`\n\nthen it's an indication of application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nCheck if the following registry values contain the following strings\n(case insensitive):\n\nDetect\n\nRegistry path\n\nRegistry key\n\nString\n\n\[general\]\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosDate\n\n06/23/99\n\nHKLM\\HARDWARE\\Description\\System\\BIOS\n\nSystemProductName\n\nA M I\n\nBOCHS\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nBOCHS\n\nHKLM\\HARDWARE\\Description\\System\n\nVideoBiosVersion\n\nBOCHS\n\nAnubis\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n\nProductID\n\n76487-337-8429955-22614\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\n\nProductID\n\n76487-337-8429955-22614\n\nCwSandbox\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n\nProductID\n\n76487-644-3177037-23510\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\n\nProductID\n\n76487-644-3177037-23510\n\nJoeBox\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\n\nProductID\n\n55274-640-2673064-23950\n\nHKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\n\nProductID\n\n55274-640-2673064-23950\n\nParallels\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nPARALLELS\n\nHKLM\\HARDWARE\\Description\\System\n\nVideoBiosVersion\n\nPARALLELS\n\nQEMU\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nQEMU\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nQEMU\n\nHKLM\\HARDWARE\\Description\\System\n\nVideoBiosVersion\n\nQEMU\n\nHKLM\\HARDWARE\\Description\\System\\BIOS\n\nSystemManufacturer\n\nQEMU\n\nVirtualBox\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVBOX\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVBOX\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVBOX\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nVBOX\n\nHKLM\\HARDWARE\\Description\\System\n\nVideoBiosVersion\n\nVIRTUALBOX\n\nHKLM\\HARDWARE\\Description\\System\\BIOS\n\nSystemProductName\n\nVIRTUAL\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVBOX\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\nFriendlyName\n\nVBOX\n\nHKLM\\SYSTEM\\ControlSet002\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVBOX\n\nHKLM\\SYSTEM\\ControlSet002\\Services\\Disk\\Enum\n\nFriendlyName\n\nVBOX\n\nHKLM\\SYSTEM\\ControlSet003\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVBOX\n\nHKLM\\SYSTEM\\ControlSet003\\Services\\Disk\\Enum\n\nFriendlyName\n\nVBOX\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\SystemInformation\n\nSystemProductName\n\nVIRTUAL\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\SystemInformation\n\nSystemProductName\n\nVIRTUALBOX\n\nVMware\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVMWARE\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 1\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVMWARE\n\nHKLM\\HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 2\\Scsi Bus 0\\Target Id\n0\\Logical Unit Id 0\n\nIdentifier\n\nVMWARE\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nVMWARE\n\nHKLM\\HARDWARE\\Description\\System\n\nSystemBiosVersion\n\nINTEL - 6040000\n\nHKLM\\HARDWARE\\Description\\System\n\nVideoBiosVersion\n\nVMWARE\n\nHKLM\\HARDWARE\\Description\\System\\BIOS\n\nSystemProductName\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\n0\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\n1\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet001\\Services\\Disk\\Enum\n\nFriendlyName\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet002\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet002\\Services\\Disk\\Enum\n\nFriendlyName\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet003\\Services\\Disk\\Enum\n\nDeviceDesc\n\nVMware\n\nHKLM\\SYSTEM\\ControlSet003\\Services\\Disk\\Enum\n\nFriendlyName\n\nVMware\n\nHKCR\\Installer\\Products\n\nProductName\n\nvmware tools\n\nHKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\n\nDisplayName\n\nvmware tools\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\n\nDisplayName\n\nvmware tools\n\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\n\nDisplayName\n\nvmware tools\n\nHKLM\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\n\nCoInstallers32\n\n\*vmx\*\n\nHKLM\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\n\nDriverDesc\n\nVMware\*\n\nHKLM\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\n\nInfSection\n\nvmx\*\n\nHKLM\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\n\nProviderName\n\nVMware\*\n\nHKLM\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\Settings\n\nDevice Description\n\nVMware\*\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\SystemInformation\n\nSystemProductName\n\nVMWARE\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Video\\{GUID}\\Video\n\nService\n\nvm3dmp\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Video\\{GUID}\\Video\n\nService\n\nvmx\_svga\n\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Video\\{GUID}\\0000\n\nDevice Description\n\nVMware SVGA\*\n\nXen\n\nHKLM\\HARDWARE\\Description\\System\\BIOS\n\nSystemProductName\n\nXen\n\n\n\\n\n### [3. Check if VBAWarnings enabled]{#check-if-vbawarning-enabled .a-dummy}\n\n"Enable all macros" prompt in Office documents means the macros can be\nexecuted without any user interaction. This behavior is common for\nsandboxes. A malware can use that in order to check if it is running on\na sandbox checking the flag in the registry keys\n`SOFTWARE\Microsoft\Office<version>\Word\Security\VBAWarnings` while the\nversion is between 12.0 to 19.0.\n\n\n**Code sample**\n\n    // Function to check if VBScript warnings are enabled in Office\n    bool IsVBScriptWarningEnabled() {\n        HKEY hKey;\n        LPCWSTR keyPath = L"SOFTWARE\\Microsoft\\Office\\<Office_Version>\\Common\\Security";\n        LPCWSTR valueName = L"VBAScriptWarnings";\n\n        // Open the registry key\n        LONG result = RegOpenKeyEx(HKEY_CURRENT_USER, keyPath, 0, KEY_READ, &hKey);\n        if (result == ERROR_SUCCESS) {\n            DWORD dwType;\n            DWORD dwValue;\n            DWORD dwSize = sizeof(DWORD);\n\n            // Query the value of VBAScriptWarnings\n            result = RegQueryValueEx(hKey, valueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &dwSize);\n            if (result == ERROR_SUCCESS && dwType == REG_DWORD && dwValue == 1) {\n                // VBScript warnings are enabled\n                RegCloseKey(hKey);\n                return true;\n            }\n            RegCloseKey(hKey);\n        }\n        return false;\n    }\n\n    int main() {\n        if (IsVBScriptWarningEnabled()) {\n            std::cout << "VBScript warnings are enabled in Office." << std::endl;\n        } else {\n            std::cout << "VBScript warnings are not enabled in Office." << std::endl;\n        }\n\n        return 0;\n    }\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nHook target functions and return appropriate results if indicators\n(registry strings from tables) are checked.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   pafish project on [github](https://github.com/a0rtega/pafish)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: Timing {#evasions-timing .post-title-main itemprop="name headline"}\n================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[Time-based sandbox evasion\ntechniques](#time-based-sandbox-evasion-techniques)\\n[1. Delayed execution](#delayed-execution)\\n[1.1. Simple delaying operation](#simple-delaying-operation)\\n[1.2. Deferred execution using Task\nScheduler](#deferred-execution-using-task-scheduler)\\n[1.3. No suspicious actions until\nreboot](#no-suspicious-actions-until-reboot)\\n[1.4. Running only on certain dates](#running-only-on-certain-dates)\\n[2. Sleep skipping detection](#sleep-skipping-detection)\\n[2.1. Parallel delays using different methods](#parallel-delays)\\n[2.2. Measure time intervals using different\nmethods](#measure-time-intervals)\\n[2.3. Get system time using different methods](#get-system-time)\\n[2.4. Check if the delay value changes after calling a delay\nfunction](#delay-value-changed)\\n[2.5. Use absolute timeout](#absolute-timeout)\\n[2.6. Get time from another process](#get-time-another-process)\\n[3. Get the current date and time from an external source (NTP,\nHTTP)](#get-time-ntp)\\n[4. Difference in time measurement in VM and\nhosts](#difference-vm-hosts)\\n[4.1. RDTSC (with CPUID to force a VM Exit)](#rdtsc)\\n[4.2. RDTSC (Locky version with GetProcessHeap and\nCloseHandle)](#rdtsc-locky)\\n[5. Check the system last boot time using different\nmethods](#check-system-boot-time)\\n[6. Call a potentially hooked delay function with invalid\narguments](#call-hooked-function-with-invalid-arguments)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[Time-based sandbox evasion techniques]{#time-based-sandbox-evasion-techniques .a-dummy}\n\nSandbox emulation usually lasts a short time because sandboxes are heavy\nloaded with thousands of samples. Emulation time rarely exceeds 3-5\nminutes. Therefore, malware can use this fact to avoid detection: it may\nperform long delays before starting any malicious activity.\\nTo counteract this, sandboxes may implement features which manipulate\ntime and execution delays. For example, the Cuckoo sandbox has a sleep\nskipping feature that replaces delays with a very short value. This\nshould force the malware to start its malicious activity before an\nanalysis timeout.\n\n::: {style="text-align: center"}\n![](../assets/images/sleep_skipping.png)\n:::\n\n\\nHowever, this can also be used to detect a sandbox.\\nThere are also some differences in the time of execution of some\ninstructions and API functions that can be used to detect a virtual\nenvironment.\n\n*Signature recommendations are not provided for this class of techniques\nas executing functions described in this chapter does not imply their\nusage for evasion purposes. It is hard to differentiate between the code\nwhich aims to perform an evasion code and the one which uses the same\nfunctions with non-evasion intentions.*\n\n\\n\n### [1. Delayed execution]{#delayed-execution .a-dummy}\n\nExecution delays are used to avoid detection of malicious activity\nduring the emulation time.\\n\n#### [1.1. Simple delaying operation]{#simple-delaying-operation .a-dummy}\n\nFunctions used:\n\n-   `Sleep, SleepEx, NtDelayExecution`\n-   `WaitForSingleObject, WaitForSingleObjectEx, NtWaitForSingleObject`\n-   `WaitForMultipleObjects, WaitForMultipleObjectsEx, NtWaitForMultipleObjects`\n-   `SetTimer, SetWaitableTimer, CreateTimerQueueTimer`\n-   `timeSetEvent` (multimedia timers)\n-   `IcmpSendEcho`\n-   `select` (Windows sockets)\n\nWhile the use of most of these functions is obvious, we show examples of\nusing the `timeSetEvent` function from Multimedia API and the `select`\nfunction from the Windows sockets API.\\n\\n**Code sample (delay using the "select" function)**\n\n    int iResult;\n    DWORD timeout = delay; // delay in milliseconds\n    DWORD OK = TRUE;\n\n    SOCKADDR_IN sa = { 0 };\n    SOCKET sock = INVALID_SOCKET;\n\n    // this code snippet should take around Timeout milliseconds\n    do {\n        memset(&sa, 0, sizeof(sa));\n        sa.sin_family = AF_INET;\n        sa.sin_addr.s_addr = inet_addr("8.8.8.8");    // we should have a route to this IP address\n        sa.sin_port = htons(80); // we should not be able to connect to this port\n\n        sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == INVALID_SOCKET) {\n            OK = FALSE;\n            break;\n        }\n\n        // setting socket timeout\n        unsigned long iMode = 1;\n        iResult = ioctlsocket(sock, FIONBIO, &iMode);\n\n        iResult = connect(sock, (SOCKADDR*)&sa, sizeof(sa));\n        if (iResult == false) {\n            OK = FALSE;\n            break;\n        }\n\n        iMode = 0;\n        iResult = ioctlsocket(sock, FIONBIO, &iMode);\n        if (iResult != NO_ERROR) {\n            OK = FALSE;\n            break;\n        }\n\n        // fd set data\n        fd_set Write, Err;\n        FD_ZERO(&Write);\n        FD_ZERO(&Err);\n        FD_SET(sock, &Write);\n        FD_SET(sock, &Err);\n        timeval tv = { 0 };\n        tv.tv_usec = timeout * 1000;\n\n        // check if the socket is ready, this call should take Timeout milliseconds\n        select(0, NULL, &Write, &Err, &tv);\n        \n        if (FD_ISSET(sock, &Err)) {\n            OK = FALSE;\n            break;\n        }\n\n    } while (false);\n\n    if (sock != INVALID_SOCKET)\n        closesocket(sock);\n\n\\n**Code sample (delay using the "timeSetEvent" function)**\n\n    VOID CALLBACK TimerFunction(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)\n    {\n        bProcessed = TRUE;\n    }\n\n    VOID timing_timeSetEvent(UINT delayInSeconds)\n    {\n        // Some vars\n        UINT uResolution;\n        TIMECAPS tc;\n        MMRESULT idEvent;\n\n        // We can obtain this minimum value by calling\n        timeGetDevCaps(&tc, sizeof(TIMECAPS));\n        uResolution = min(max(tc.wPeriodMin, 0), tc.wPeriodMax);\n\n        // Create the timer\n        idEvent = timeSetEvent(\n            delayInSeconds,\n            uResolution,\n            TimerFunction,\n            0,\n            TIME_ONESHOT);\n\n        while (!bProcessed){\n            // wait until our function finishes\n            Sleep(0);\n        }\n\n        // destroy the timer\n        timeKillEvent(idEvent);\n\n        // reset the timer\n        timeEndPeriod(uResolution);\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\\n\n#### [1.2. Deferred execution using Task Scheduler]{#deferred-execution-using-task-scheduler .a-dummy}\n\nThis method can be used both for delaying execution and evading sandbox\ntracking.\\n\\n**Code sample (PowerShell)**\n\n        $tm = (get-date).AddMinutes(10).ToString("HH:mm")\n        $action = New-ScheduledTaskAction -Execute "some_malicious_app.exe"\n        $trigger = New-ScheduledTaskTrigger -Once -At $tm\n        Register-ScheduledTask TaskName -Action $action -Trigger $trigger\n\n\\n\n#### [1.3. No suspicious actions until reboot]{#no-suspicious-actions-until-reboot .a-dummy}\n\nThe idea behind this technique is that a sandbox doesn't reboot a\nvirtual machine during the emulation of a malicious sample. The malware\nmay just set up persistence using any of available methods and silently\nexit. Malicious actions are performed only after the system is rebooted.\n\n#### [1.4. Running only on certain dates]{#running-only-on-certain-dates .a-dummy}\n\nMalware samples may check the current date and perform malicious actions\nonly on certain dates. For example, this technique was used in the\n[Sazoora\nmalware](https://www.cyphort.com/sazoora-dissecting-bundle-evasion-stealth/),\nwhich checks the current date and verifies if the day is either the\n16th, 17th or 18th of a given month.\n\n**Example:**\n\n::: {style="text-align: center"}\n![](../assets/images/date_anti_sb.png)\n:::\n\n\\n\n**Countermeasures**\n\nCountermeasures for this class of evasion techniques should be\ncomprehensive and include all described attack vectors. The\nimplementation cannot be simple and its description deserves a separate\narticle. Therefore, we only provide general recommendations here:\n\n-   Implement sleep skipping.\n-   System-wide dynamic time flow speed manipulation.\n-   Run emulation multiple times on different dates.\n\nAlthough sleep skipping is already implemented in the Cuckoo sandbox, it\nis very easy to deceive it. Sleep skipping is disabled after a new\nthread or process is created to avoid sleep skipping detection. However,\nit can still be easily detected as shown below.\n\n### [2. Sleep skipping detection]{#sleep-skipping-detection .a-dummy}\n\nTechniques of this type are generally aimed at the Cuckoo monitor sleep\nskipping feature and other time-manipulation techniques that can be used\nin sandboxes to skip long delays performed by the malware.\n\n#### [2.1. Parallel delays using different methods]{#parallel-delays .a-dummy}\n\nThe idea behind the techniques is to perform different types of delays\nin parallel and to measure the elapsed time.\\n\\n**Code sample**\n\n    DWORD StartingTick, TimeElapsedMs;\n    LARGE_INTEGER DueTime;\n    HANDLE hTimer = NULL;\n    TIMER_BASIC_INFORMATION TimerInformation;\n    ULONG ReturnLength;\n\n    hTimer = CreateWaitableTimer(NULL, TRUE, NULL);\n    DueTime.QuadPart = Timeout * (-10000LL);\n\n    StartingTick = GetTickCount();\n    SetWaitableTimer(hTimer, &DueTime, 0, NULL, NULL, 0);\n    do\n    {\n        Sleep(Timeout/10);\n        NtQueryTimer(hTimer, TimerBasicInformation, &TimerInformation, sizeof(TIMER_BASIC_INFORMATION), &ReturnLength);\n    } while (!TimerInformation.TimerState);\n\n    CloseHandle(hTimer);\n\n    TimeElapsedMs = GetTickCount() - StartingTick;\n    printf("Requested delay: %d, elapsed time: %d\n", Timeout, TimeElapsedMs);\n\n    if (abs((LONG)(TimeElapsedMs - Timeout)) > Timeout / 2)\n        printf("Sleep-skipping DETECTED!\n");\n\n\\nIn the code sample above, the delay timeout is set using the\n`SetWaitableTimer()` timer function. The `Sleep()` function is called in\na loop until the timer timeout. In the Cuckoo sandbox, delays that are\nperformed by the `Sleep()` function are skipped (replaced with a very\nshort timeout) and the virtually elapsed time will be much higher than\nthe requested timeout:\n\n        Requested delay: 60000, elapsed time: 1906975\n        Sleep-skipping DETECTED!\n\n\\n\n#### [2.2. Measure time intervals using different methods]{#measure-time-intervals .a-dummy}\n\nWe need to perform a delay that will be skipped in a sandbox and to\nmeasure elapsed time using different methods. While the Cuckoo monitor\nhooks the `GetTickCount()`, `GetLocalTime()`, `GetSystemTime()` and\nmakes them return the skipped time, we still can find methods to measure\ntime that are not handled by the Cuckoo monitor.\n\nFunctions used:\n\n-   `GetTickCount64`\n-   `QueryPerformanceFrequency, QueryPerformanceCounter`\n-   `NtQuerySystemInformation`\n\n\\n\\n**Code sample (using "QueryPerformanceCounter" to measure elapsed\ntime)**\n\n    LARGE_INTEGER StartingTime, EndingTime;\n    LARGE_INTEGER Frequency;\n    DWORD TimeElapsedMs;\n\n    QueryPerformanceFrequency(&Frequency);\n    QueryPerformanceCounter(&StartingTime);\n\n    Sleep(Timeout);\n\n    QueryPerformanceCounter(&EndingTime);\n    TimeElapsedMs = (DWORD)(1000ll * (EndingTime.QuadPart - StartingTime.QuadPart) / Frequency.QuadPart);\n\n    printf("Requested delay: %d, elapsed time: %d\n", Timeout, TimeElapsedMs);\n\n    if (abs((LONG)(TimeElapsedMs - Timeout)) > Timeout / 2)\n        printf("Sleep-skipping DETECTED!\n");\n\n\\n\\n**Code sample (using "GetTickCount64" to measure elapsed time)**\n\n    ULONGLONG tick;\n    DWORD TimeElapsedMs;\n\n    tick = GetTickCount64();\n    Sleep(Timeout);\n    TimeElapsedMs = GetTickCount64() - tick;\n\n    printf("Requested delay: %d, elapsed time: %d\n", Timeout, TimeElapsedMs);\n\n    if (abs((LONG)(TimeElapsedMs - Timeout)) > Timeout / 2)\n        printf("Sleep-skipping DETECTED!\n");\n\nWe can also use our own implementation of `GetTickCount` to detect sleep\nskipping. In the next code sample, we acquire the tick count directly\nfrom the `KUSER_SHARED_DATA` structure. This way we can get the original\ntick count value even if the `GetTickCount()` function was hooked.\\n\\n**Code sample (getting the tick count from the KUSER\_SHARED\_DATA\nstructure)**\n\n    #define KI_USER_SHARED_DATA         0x7FFE0000\n    #define SharedUserData  ((KUSER_SHARED_DATA * const) KI_USER_SHARED_DATA)\n    #define MyGetTickCount() ((DWORD)((SharedUserData->TickCountMultiplier * (ULONGLONG)SharedUserData->TickCount.LowPart) >> 24))\n\n    // ...\n    StartingTick = MyGetTickCount();\n    Sleep(Timeout);\n    TimeElapsedMs = MyGetTickCount() - StartingTick;\n\n    printf("Requested delay: %d, elapsed time: %d\n", Timeout, TimeElapsedMs);\n\n    if (abs((LONG)(TimeElapsedMs - Timeout)) > Timeout / 2)\n        printf("Sleep-skipping DETECTED!\n");\n\n\\n\n#### [2.3. Get system time using different methods]{#get-system-time .a-dummy}\n\nThis method is similar to the previous one. Instead of measuring\nintervals we try to obtain the current system time using different\nmethods.\\n\\n**Code sample**\n\n    SYSTEM_TIME_OF_DAY_INFORMATION  SysTimeInfo;\n    ULONGLONG time;\n    LONGLONG diff;\n\n    Sleep(60000); // should trigger sleep skipping\n    GetSystemTimeAsFileTime((LPFILETIME)&time);\n\n    NtQuerySystemInformation(SystemTimeOfDayInformation, &SysTimeInfo, sizeof(SysTimeInfo), 0);\n    diff = time - SysTimeInfo.CurrentTime.QuadPart;\n    if (abs(diff) > 10000000) // differ in more than 1 second\n        printf("Sleep-skipping DETECTED!\n);\n\n\\n\n#### [2.4. Check if the delay value changes after calling a delay function]{#delay-value-changed .a-dummy}\n\nSleep-skipping is usually implemented as a replacement of the delay\nvalue with a smaller interval. Let's look at the `NtDelayExecution`\nfunction. The delay value is passed to this function using a pointer:\\n\n    NTSYSAPI NTSTATUS NTAPI\n    NtDelayExecution(\n        IN BOOLEAN              Alertable,\n        IN PLARGE_INTEGER       DelayInterval );\n\n\\nTherefore, we can check if the value of `DelayInterval` changes after\nthe function execution. If the value differs from the initial value, the\ndelay was skipped.\\n\\n**Code sample**\n\n    LONGLONG SavedTimeout = Timeout * (-10000LL);\n    DelayInterval->QuadPart = SavedTimeout;\n    status = NtDelayExecution(TRUE, DelayInterval);\n    if (DelayInterval->QuadPart != SavedTimeout)\n        printf("Sleep-skipping DETECTED!\n");\n\n\\n\n#### [2.5. Use absolute timeout]{#absolute-timeout .a-dummy}\n\nFor Nt-functions that perform delays we can use either a relative delay\ninterval or an absolute time for timeout. A negative value for the delay\ninterval means a relative timeout, and a positive value means an\nabsolute timeout. High-level API functions such as\n`WaitForSingleObject()` or `Sleep()` operate with relative intervals.\nTherefore sandbox developers may not care about absolute timeouts and\nhandle them incorrectly. In the Cuckoo sandbox such delays are skipped,\nbut skipped time and ticks are counted incorrectly. This can be used to\ndetect sleep skipping.\\n\\n**Code sample**\n\n    void SleepAbs(DWORD ms)\n    {\n        LARGE_INTEGER SleepUntil;\n\n        GetSystemTimeAsFileTime((LPFILETIME)&SleepUntil);\n        SleepTo.QuadPart += (ms * 10000);\n        NtDelayExecution(TRUE, &SleepTo);\n    }\n\n\\n\n#### [2.6. Get time from another process]{#get-time-another-process .a-dummy}\n\nSleep skipping in the Cuckoo sandbox is not system-wide. Therefore, if\nthere are performing delays, time moves with different speeds in the\ndifferent processes. After a delay we should synchronize the processes\nand compare the current time in the two processes. A big difference in\nmeasured time values indicates sleep skipping was performed.\n\n::: {style="text-align: center"}\n![](../assets/images/sleep_skipping_detection.png)\n:::\n\nThe current version of the Cuckoo monitor disables sleep skipping after\ncreating new threads or processes. Therefore, we should use a process\ncreation method that is not tracked by the Cuckoo monitor, for example,\nusing a scheduled task.\n\n\\n\n### [3. Get the current date and time from an external source (NTP, HTTP)]{#get-time-ntp .a-dummy}\n\nA sandbox may set different dates to check how the behavior of analyzed\nsamples is changed depending on the date. The malware can use an\nexternal date and time source to prevent time manipulation attempts\ninside the VM. This method can also be used to measure time intervals,\nperform delays, and detect sleep skipping attempts. NTP servers, and the\nHTTP header "Date" can be used as an external source for the date and\ntime. For example, the malware may connect to `google.com` to check the\ncurrent date and use it as a DGA seed.\n\n**Countermeasures**\n\nImplement fake web infrastructure or spoof NTP data and HTTP headers\nreturned by real servers. The returned/spoofed date and time should be\nsynchronized with the date and time in a virtual machine.\n\n\\n\n### [4. Difference in time measurement in VM and hosts]{#difference-vm-hosts .a-dummy}\n\nThe execution of some API functions and instructions may take different\namounts of time in a VM and in the usual host systems. These\npeculiarities can be used to detect a virtual environment.\n\n#### [4.1. RDTSC (with CPUID to force a VM Exit)]{#rdtsc .a-dummy}\n\n**Code sample**\n\n    BOOL rdtsc_diff_vmexit()\n    {\n        ULONGLONG tsc1 = 0;\n        ULONGLONG tsc2 = 0;\n        ULONGLONG avg = 0;\n        INT cpuInfo[4] = {};\n\n        // Try this 10 times in case of small fluctuations\n        for (INT i = 0; i < 10; i++)\n        {\n            tsc1 = __rdtsc();\n            __cpuid(cpuInfo, 0);\n            tsc2 = __rdtsc();\n\n            // Get the delta of the two RDTSC\n            avg += (tsc2 - tsc1);\n        }\n\n        // We repeated the process 10 times so we make sure our check is as much reliable as we can\n        avg = avg / 10;\n        return (avg < 1000 && avg > 0) ? FALSE : TRUE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\\n\n#### [4.2. RDTSC (Locky version with GetProcessHeap and CloseHandle)]{#rdtsc-locky .a-dummy}\n\n**Code sample**\n\n    #define LODWORD(_qw)    ((DWORD)(_qw))\n    BOOL rdtsc_diff_locky()\n    {\n        ULONGLONG tsc1;\n        ULONGLONG tsc2;\n        ULONGLONG tsc3;\n        DWORD i = 0;\n\n        // Try this 10 times in case of small fluctuations\n        for (i = 0; i < 10; i++)\n        {\n            tsc1 = __rdtsc();\n\n            // Waste some cycles - should be faster than CloseHandle on bare metal\n            GetProcessHeap();\n\n            tsc2 = __rdtsc();\n\n            // Waste some cycles - slightly longer than GetProcessHeap() on bare metal\n            CloseHandle(0);\n\n            tsc3 = __rdtsc();\n\n            // Did it take at least 10 times more CPU cycles to perform CloseHandle than it took to perform GetProcessHeap()?\n            if ((LODWORD(tsc3) - LODWORD(tsc2)) / (LODWORD(tsc2) - LODWORD(tsc1)) >= 10)\n                return FALSE;\n        }\n\n        // We consistently saw a small ratio of difference between GetProcessHeap and CloseHandle execution times\n        // so we're probably in a VM!\n        return TRUE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n**Countermeasures**\n\nImplement `RDTSC` instruction "hooking." It is possible to make RDTSC a\nprivileged instruction that can be called in kernel-mode only. Calling\nthe "hooked" RDTSC in user-mode leads to an execution of our handler\nthat can return any desired value.\n\n\\n\n### [5. Check the system last boot time using different methods]{#check-system-boot-time .a-dummy}\n\nThis technique is a combination of techniques described in [Generic OS\nqueries: Check if the system uptime is\nsmall](generic-os-queries.html#check-if-system-uptime) and [WMI: Check\nthe last boot time](wmi.html#check-last-boot-time) sections. Depending\non a method used for getting system last boot time, the measured sandbox\nOS uptime can be too small (several minutes), or conversely, too big\n(months or even years), because the system is usually restored from a\nsnapshot after the analysis starts.\\nWe can detect a sandbox by comparing the two values for the last boot\ntime, acquired through WMI and through\n`NtQuerySystemInformation(SystemTimeOfDayInformation)`.\\n\\n\n**Code sample**\n\n    bool check_last_boot_time()\n    {\n        SYSTEM_TIME_OF_DAY_INFORMATION  SysTimeInfo;\n        LARGE_INTEGER LastBootTime;\n        \n        NtQuerySystemInformation(SystemTimeOfDayInformation, &SysTimeInfo, sizeof(SysTimeInfo), 0);\n        LastBootTime = wmi_Get_LastBootTime();\n        return (wmi_LastBootTime.QuadPart - SysTimeInfo.BootTime.QuadPart) / 10000000 != 0; // 0 seconds\n    }\n\n**Countermeasures**\n\n-   Adjust the `KeBootTime` value\n-   Reset the WMI repository or restart the `"winmgmt"` service after\n    the `KeBootTime` adjustment\n\n\\n\n### [6. Call a potentially hooked delay function with invalid arguments]{#call-hooked-function-with-invalid-arguments .a-dummy}\n\nThe second argument of the `NtDelayExecution` function is a pointer to\nthe delay interval value. In the kernel-mode, the `NtDelayExecution`\nfunction validates this pointer and can also return the following\nvalues:\n\n-   `STATUS_ACCESS_VIOLATION` - If the value is not a valid user-mode\n    address\n-   `STATUS_DATATYPE_MISALIGNMENT` - If the address is not aligned\n    (DelayInterval & 3 != 0)\n\nIn a sandbox, the input arguments for `NtDelayExecution` and similar\nfunctions might not be handled correctly. If we call `NtDelayExecution`\nwith an unaligned pointer for DelayInterval, normally it returns the\n`STATUS_DATATYPE_MISALIGNMENT`. However, in a sandbox, the value for\nDelayInterval may be copied to a new variable without the appropriate\nchecks. In this case, a delay is performed and the returned value will\nbe `STATUS_SUCCESS`. This can be used to detect a sandbox.\\n\\n**Code sample**\n\n    __declspec(align(4)) BYTE aligned_bytes[sizeof(LARGE_INTEGER) * 2];\n    DWORD tick_start, time_elapsed_ms;\n    DWORD Timeout = 10000; //10 seconds\n    PLARGE_INTEGER DelayInterval = (PLARGE_INTEGER)(aligned_bytes + 1); //unaligned\n    NTSTATUS status;\n\n    DelayInterval->QuadPart = Timeout * (-10000LL);\n    tick_start = GetTickCount();\n    status = NtDelayExecution(FALSE, DelayInterval);\n    time_elapsed_ms = GetTickCount() - tick_start;\n    // If the pointer is not aligned the delay should not be performed\n    if (time_elapsed_ms > 500 || status != STATUS_DATATYPE_MISALIGNMENT )\n        printf("Sandbox detected\n");\n\nOn the other hand, if an inaccessible address is set for DelayInterval,\nthe return code should be `STATUS_ACCESS_VIOLATION`. This can be used to\ndetect a sandbox as well.\\n\\n**Code sample**\n\n    if (NtDelayExecution(FALSE, (PLARGE_INTEGER)0) != STATUS_ACCESS_VIOLATION)\n        printf("Sandbox detected");\n\nIf the `DelayInterval` argument is not verified before it is accessed,\nthis may lead to an exception in the case of using an invalid pointer.\nFor example, the next code leads the Cuckoo monitor to crash.\\n\\n**Code sample**\n\n    NtDelayExecution(FALSE, (PLARGE_INTEGER)0xFFDF0000);\n\nAs stated earlier, normally this call should return\n`STATUS_ACCESS_VIOLATION` without causing an exception.\n\n**Countermeasures**\n\nHooked functions should check arguments and return appropriate error\ncodes if arguments are invalid.\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nCountermeasures are present in the appropriate sub-sections above.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source projects from where code samples were taken:\n\n-   al-khaser project on\n    [GitHub](https://github.com/LordNoteworthy/al-khaser)\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: UI artifacts {#evasions-ui-artifacts .post-title-main itemprop="name headline"}\n======================\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[UI artifacts detection methods](#ui-artifacts-detection-methods)\\n[1. Check if windows with certain class names are present in the\nOS](#check-windows-with-certain-class)\\n[2. Check if top level windows' number is too\nsmall](#check-number-of-top-level-windows)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[UI artifacts detection methods]{#ui-artifacts-detection-methods .a-dummy}\n\nTechniques described in this group abuse the fact that some windows'\nnames are only present in virtual environment and not is usual host OS.\nEven more, host OS contains a lot of windows while VM and sandboxes\nprefer keeping opened windows at the minimum. Their quantity is checked\nand the conclusion is drawn whether it is a VM or not.\n\n\\n\n### [1. Check if windows with certain class names are present in the OS]{#check-windows-with-certain-class .a-dummy}\n\n**Detections table**\n\nCheck if windows with the following class names are present in the OS:\n:::\n:::\n:::\n:::\n\nDetect\n\nClass name\n\nVirtualBox\n\nVBoxTrayToolWndClass\n\nVBoxTrayToolWnd\n\n\n**Code sample**\n\n    BOOL vbox_window_class()\n    {\n      HWND hClass = FindWindow(_T("VBoxTrayToolWndClass"), NULL);\n      HWND hWindow = FindWindow(NULL, _T("VBoxTrayToolWnd"));\n\n      if (hClass || hWindow)\n        return TRUE;\n      else\n        return FALSE;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\\n\n### [2. Check if top level windows\' number is too small]{#check-number-of-top-level-windows .a-dummy}\n\nAs it was stated above, host OS contains a lot of windows while VMs and\nsandboxes strive to keep opened windows at possible minimum. Windows\ncount is measured and the conclusion is drawn on whether it's a VM or\nnot.\\nIn case there are too few windows in the OS, it could be an indication\nof virtual environment. Typical hosts have a lot (\>10) top level\nwindows.\n\n\n**Code sample**\n\n    BOOL CALLBACK enumProc(HWND, LPARAM lParam)\n    {\n        if (LPDWORD pCnt = reinterpret_cast<LPDWORD>(lParam))\n            *pCnt++;\n        return TRUE;\n    }\n\n    bool enumWindowsCheck(bool& detected)\n    {\n        DWORD winCnt = 0;\n\n        if (!EnumWindows(enumProc,LPARAM(&winCnt))) {\n            std::cerr << "EnumWindows() failed\n";\n            return false;\n        }\n\n        return winCnt < 10;\n    }\n\n\\n\n### [Signature recommendations]{#signature-recommendations .a-dummy}\n\n*No signature recommendations are provided for this evasion group as\nit's hard to tell that code aims to perform some evasion technique and\nnot "legal" action.*\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\n-   `versus windows with certain class names:` Exclude windows with\n    particular names from enumeration or modify these names.\n-   `versus checking top level windows' number:` Create fake windows in\n    the system so that their number will not be small or equal to the\n    predefined numbers.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\nCredits go to open-source project from where code samples were taken:\n\n-   al-khaser project on\n    [github](https://github.com/LordNoteworthy/al-khaser)\n\nThough Check Point tool InviZzzible has them all implemented, due to\nmodular structure of the code it would require more space to show a code\nsample from this tool for the same purposes. That's why we've decided to\nuse other great open-source projects for examples throughout the\nencyclopedia.\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n\n::: {.section}\n::: {.jumbotron}\n::: {.container}\nEvasions: WMI {#evasions-wmi .post-title-main itemprop="name headline"}\n=============\n:::\n:::\n\n::: {.post-content .container itemprop="articleBody"}\n::: {style="text-align: left"}\n[Go back](..)\\n\\n:::\n\nContents\n========\n\n[WMI detection methods](#wmi-detection-methods)\\n[Background](#background)\\n[1. Generic WMI queries](#generic-wmi-queries)\\n[2. Escape from tracking using WMI](#escape-from-tracking)\\n[2.1. Start process using WMI](#wmi-process)\\n[2.2. Start process using Task Scheduler via WMI](#wmi-tsched)\\n[3. Check the last boot time](#check-last-boot-time)\\n[4. Check the network adapter last reset\ntime](#check-network-adapter-reset-time)\\n[Signature recommendations](#signature-recommendations)\\n[Countermeasures](#countermeasures)\\n[Credits](#credits)\\n\\n\n\n[WMI detection methods]{#wmi-detection-methods .a-dummy}\n--------------------------------------------------------\n\nWindows Management Interface (WMI) queries are another way to get OS and\nhardware information. WMI uses COM interfaces and their methods.\n\n\n[Background]{#background .a-dummy}\n----------------------------------\n\nStandard COM functions are used to process queries. They are called in\nthe sequence described below and can be split into 6 steps.\n\n1\. COM initialization:\n\n-   `CoInitialize/CoInitializeEx`\n\n\n2\. Create the required interface instance:\n\n-   `CoCreateInstance/CoCreateInstanceEx`\n\n\n3\. Connect to the particular services via the interface instance with\nthe following function:\n\n-   `ConnectServer`\n\n\n4\. Get methods of the services and set their arguments with these\nfunctions:\n\n-   `Method` (to get methods)\n-   `Put` (to set arguments)\n\n\n5\. Retrieve information from the services and execute the methods of\nthe services with the functions below. The functions on the left are\nproxies for the functions on the right - which are called internally:\n\n-   `ExecQuery -> IWbemServices_ExecQuery` (retrieve information)\n-   `ExecMethod -> IWbemServices_ExecMethod` (execute method)\n-   `ExecMethodAsync -> IWbemServices_ExecMethodAsync` (execute method)\n\n\n6\. Examine the result of the query with the following functions:\n\n-   `[enumerator]->Next`\n-   `[object]->Get`\n\n\nTo see how the described theory is applied to practice, please check the\nexamples below.\n\n\\n\n### [1. Generic WMI queries]{#generic-wmi-queries .a-dummy}\n\nAs WMI provides another way to collect system information, it can be\nused to perform evasion techniques described in other articles, for\nexample:\n\n-   [Check if the number of processors is\n    low](generic-os-queries.html#check-if-number-of-processors)\n-   [Check if the hard disk size is\n    small](generic-os-queries.html#check-if-hard-disk)\n-   [Check if the MAC address is\n    specific](network.html#check-if-mac-address-is-specific)\n-   [Check if the CPU temperature information is\n    available](hardware.html#check-if-cpu-temperature-information-is-available)\n\n**Code sample**\n\n    /*\n    Check number of cores using WMI\n    */\n    BOOL number_cores_wmi()\n    {\n      IWbemServices *pSvc = NULL;\n      IWbemLocator *pLoc = NULL;\n      IEnumWbemClassObject *pEnumerator = NULL;\n      BOOL bStatus = FALSE;\n      HRESULT hRes;\n      BOOL bFound = FALSE;\n\n      // Init WMI\n      bStatus = InitWMI(&pSvc, &pLoc);\n      if (bStatus)\n      {\n        // If success, execute the desired query\n        bStatus = ExecWMIQuery(&pSvc, &pLoc, &pEnumerator, _T("SELECT * FROM Win32_Processor"));\n        if (bStatus)\n        {\n          // Get the data from the query\n          IWbemClassObject *pclsObj = NULL;\n          ULONG uReturn = 0;\n          VARIANT vtProp;\n\n          // Iterate over our enumator\n          while (pEnumerator)\n          {\n            hRes = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);\n            if (0 == uReturn)\n              break;\n\n            // Get the value of the Name property\n            hRes = pclsObj->Get(_T("NumberOfCores"), 0, &vtProp, 0, 0);\n            if (V_VT(&vtProp) != VT_NULL) {\n\n              // Do our comparaison\n              if (vtProp.uintVal < 2) {\n                bFound = TRUE; break;\n              }\n\n              // release the current result object\n              VariantClear(&vtProp);\n              pclsObj->Release();\n            }\n          }\n\n          // Cleanup\n          pEnumerator->Release();\n          pSvc->Release();\n          pLoc->Release();\n          CoUninitialize();\n        }\n      }\n\n      return bFound;\n    }\n\n\n    /*\n    Check hard disk size using WMI\n    */\n    BOOL disk_size_wmi()\n    {\n      IWbemServices *pSvc = NULL;\n      IWbemLocator *pLoc = NULL;\n      IEnumWbemClassObject *pEnumerator = NULL;\n      BOOL bStatus = FALSE;\n      HRESULT hRes;\n      BOOL bFound = FALSE;\n      INT64 minHardDiskSize = (80LL * (1024LL * (1024LL * (1024LL))));\n\n      // Init WMI\n      bStatus = InitWMI(&pSvc, &pLoc);\n      if (bStatus)\n      {\n        // If success, execute the desired query\n        bStatus = ExecWMIQuery(&pSvc, &pLoc, &pEnumerator, _T("SELECT * FROM Win32_LogicalDisk"));\n        if (bStatus)\n        {\n          // Get the data from the query\n          IWbemClassObject *pclsObj = NULL;\n          ULONG uReturn = 0;\n          VARIANT vtProp;\n\n          // Iterate over our enumator\n          while (pEnumerator)\n          {\n            hRes = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);\n            if (0 == uReturn)\n              break;\n\n            // Get the value of the Name property\n            hRes = pclsObj->Get(_T("Size"), 0, &vtProp, 0, 0);\n            if (V_VT(&vtProp) != VT_NULL) {\n\n              // Do our comparaison\n              if (vtProp.llVal < minHardDiskSize) { // Less than 80GB\n                bFound = TRUE; break;\n              }\n\n              // release the current result object\n              VariantClear(&vtProp);\n              pclsObj->Release();\n            }\n          }\n\n          // Cleanup\n          pEnumerator->Release();\n          pSvc->Release();\n          pLoc->Release();\n          CoUninitialize();\n        }\n      }\n\n      return bFound;\n    }\n\n*Credits for this code sample: [al-khaser\nproject](https://github.com/LordNoteworthy/al-khaser)*\n\n\n**Code sample (PowerShell)**\n\n    (Get-CimInstance -ClassName Win32_BIOS -Property SerialNumber).SerialNumber\n\n\n**Signature recommendations**\n\nIf the following function contains a 3rd argument from the table column\n\"Query\":\n\n-   `IWbemServices_ExecQuery(..., query, ...)`\n\nthen it's an indicator of the application trying to use the evasion\ntechnique.\n\n\n**Detections table**\n\nThe following WMI queries may be used to detect virtual environment:\n:::\n:::\n\nQuery\n\nField\n\nValue\n\nDetect\n\nComments\n\nSELECT \* FROM Win32\_Processor\n\nNumberOfCores\n\n\< 2\n\n\[general\]\n\nProcessorId\n\n\[empty\]\n\nSELECT \* FROM Win32\_LogicalDisk\n\nSize\n\n\< 60GB\n\nSELECT \* FROM Win32\_BaseBoard\n\nSerialNumber\n\nNone\n\nVersion\n\nNone\n\nSELECT \* FROM MSAcpi\_ThermalZoneTemperature\n\nCurrentTemperature\n\n\"Not supported\"\n\nSELECT \* FROM Win32\_PnPEntity\n\nDeviceId\n\nPCI\\VEN\_80EE&DEV\_CAFE\n\nVirtualBox\n\nIDE\\CDROOMVBOX\n\nIDE\\DISKVBOX\*\n\nVEN\_VMWARE\n\nVMware\n\nPROD\_VMWARE\_VIRTUAL\n\nSELECT \* FROM Win32\_NetworkAdapterConfiguration\n\nMACAddress\n\n08:00:27\n\nVirtualBox\n\nSee [\"Check if MAC address is\nspecific\"](network.html#check-if-mac-address-is-specific) section in\n\"Network\" chapter\n\n00:1C:42\n\nParallels\n\n00:05:69\n\nVMware\n\n00:0C:29\n\n00:1C:14\n\n00:50:56\n\n00:16:E3\n\nXEN\n\nSELECT \* FROM Win32\_Bios\n\nSerial Number\n\nVMware-\n\nVMware\n\n0\n\nVirtualBox\n\nVersion\n\nINTEL - 6040000\n\nVMware\n\nSee \"SystemBiosVersion\" in [\"Check if particular registry keys\ncontain specified\nstrings\"](registry.html#check-if-keys-contain-strings) section in\n\"Registry\" chapter\n\nBOCHS\n\nBOCHS\n\nPARALLELS\n\nParallels\n\nQEMU\n\nQEMU\n\nVBOX\n\nVirtualBox\n\nSELECT \* FROM Win32\_ComputerSystem\n\nModel\n\nVMware\n\nVMware\n\nVirtualBox\n\nVirtualBox\n\nManufacturer\n\nVMware\n\nVMware\n\ninnotek GmbH\n\nVirtualBox\n\nSELECT \* FROM Win32\_VideoController\n\nAdapterCompatibility\n\nVMware\n\nVMware\n\nOracle Corporation\n\nVirtualBox\n\nCaption\n\nVMware\n\nVMware\n\nVirtualBox\n\nVirtualBox\n\nDescription\n\nVMware\n\nVMware\n\nVirtualBox\n\nVirtualBox\n\nName\n\nVMware\n\nVMware\n\nVirtualBox\n\nVirtualBox\n\nSELECT \* FROM Win32\_PointingDevice\n\nDescription\n\nVMware\n\nVMware\n\n\n*Queries listed in the table are not the only ones possible, and are\npresented to give an idea of how they work and what information can be\nretrieved with these calls.*\n\n**Countermeasures**\n\nCountermeasures depend on the particular checks implemented via the WMI\nmethod and they are the same as for the corresponding methods described\nin the relevant articles. Additionally, you must restart the "`winmgmt`"\nservice.\n\n\n\\n\n### [2. Escape from tracking using WMI]{#escape-from-tracking .a-dummy}\n\nWMI provides a way to create new processes and to schedule tasks.\nSandboxes usually use the `CreateProcessInternalW` function hooking to\ntrack child processes. However, when you create the process using WMI\nthe function `CreateProcessInternalW` is not called in the parent\nprocess. Therefore, the processes created using WMI may not be tracked\nby a sandbox and their behavior will not be recorded.\\n\n#### [2.1. Start process using WMI]{#wmi-process .a-dummy}\n\nYou can create a new process with WMI using the "`Win32_Process`" class\nwith the method "`Create`".\n\n**Code sample**\n\n    // Initialize COM\n    CoInitializeEx(NULL, COINIT_MULTITHREADED);\n\n    //  Set general COM security levels\n    hres = CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0, NULL);\n    if (FAILED(hres) && hres != RPC_E_TOO_LATE)\n        break;\n\n    // create an instance of WbemLocator\n    CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID*)&wbemLocator);\n    wbemLocator->ConnectServer(CComBSTR("ROOT\\CIMV2"), NULL, NULL, NULL, 0, NULL, NULL, &wbemServices);\n\n    // get Win32_Process object\n    wbemServices->GetObject(CComBSTR("Win32_Process"), 0, NULL, &oWin32Process, &callResult);\n    wbemServices->GetObject(CComBSTR("Win32_ProcessStartup"), 0, NULL, &oWin32ProcessStartup, &callResult);\n    oWin32Process->GetMethod(CComBSTR("Create"), 0, &oMethCreate, &oMethCreateSignature);\n    oMethCreate->SpawnInstance(0, &instWin32Process);\n    oWin32ProcessStartup->SpawnInstance(0, &instWin32ProcessStartup);\n    // set startup information for process\n    instWin32ProcessStartup->Put(CComBSTR("CreateFlags"), 0, &varCreateFlags, 0);\n    instWin32Process->Put(CComBSTR("CommandLine"), 0, &varCmdLine, 0);\n    instWin32Process->Put(CComBSTR("CurrentDirectory"), 0, &varCurDir, 0);\n    CComVariant varStartupInfo(instWin32ProcessStartup);\n    instWin32Process->Put(CComBSTR("ProcessStartupInformation"), 0, &varStartupInfo, 0);\n    wbemServices->ExecMethod(CComBSTR("Win32_Process"), CComBSTR("Create"), 0, NULL, instWin32Process, &pOutParams, &callResult);\n\n*Code sample is taken from [InviZzzible\ntool](https://github.com/CheckPointSW/InviZzzible)*\n\n\n**Signature recommendations**\n\nIf one of the following functions is called with the 2nd argument\n"`Win32_Process`" and the 3rd argument "`Create`":\n\n-   `IWbemServices_ExecMethod(..., BSTR("Win32_Process"), BSTR("Create"), ...)`\n-   `IWbemServices_ExecMethodAsync(..., BSTR("Win32_Process"), BSTR("Create"), ...)`\n\nthen it's an indicator of the application trying to use the evasion\ntechnique.\n\n**Countermeasures**\n\nIf you use a kernel-mode monitor, hook target functions or register\ncallback on the process creation with\n`PsSetCreateProcessNotifyRoutineEx`.\n\n\n#### [2.2. Start process using Task Scheduler via WMI (Windows 7)]{#wmi-tsched .a-dummy}\n\nThe technique is essentially the same as described in the ["Deferred\nexecution using Task\nScheduler"](timing.html#deferred-execution-using-task-scheduler) section\nin the "Timing" chapter. WMI just provides another way to schedule a\ntask.\n\nYou can create a new task with WMI using the "`Win32_ScheduledJob`"\nclass with the method "`Create`".\n\nHowever, the "`Win32_ScheduledJob`" WMI class was designed to work with\nthe AT command, which is deprecated since Windows 8.\n\nIn Windows 8 and higher, you can only create scheduled jobs with WMI if\nthe registry key\n"`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\Configuration`"\nhas a value "`EnableAt`"="1" of type `REG_DWORD`. Therefore, this\ntechnique is unlikely to be found in the wild.\n\n**Code sample (VB)**\n\n    strComputer = "."\n    Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=Impersonate}!\\" & strComputer & "\root\cimv2") \n    Set objSWbemDateTime = CreateObject("WbemScripting.SWbemDateTime")\n    objSWbemDateTime.SetVarDate(DateAdd("n", 1, Now()))\n    Set objNewJob = objWMIService.Get("Win32_ScheduledJob")\n    errJobCreate = objNewJob.Create("malware.exe", objSWbemDateTime.Value, False, , , True, "MaliciousJob") \n\n\n**Signature recommendations**\n\nIf one of the following functions is called with the 2nd argument\n"Win32\_ScheduledJob" and the 3rd argument "Create":\n\n-   `IWbemServices_ExecMethod(..., BSTR("Win32_ScheduledJob"), BSTR("Create"), ...)`\n-   `IWbemServices_ExecMethodAsync(..., BSTR("Win32_ScheduledJob"), BSTR("Create"), ...)`\n\nthen it's an indicator of the application trying to use the evasion\ntechnique.\n\n**Countermeasures**\n\nUse a kernel-mode monitor, and register callback on the process creation\nwith PsSetCreateProcessNotifyRoutineEx.\n\n\n\\n\n### [3. Check the last boot time]{#check-last-boot-time .a-dummy}\n\nIf the last boot time is queried immediately after restoring a VM from a\nsnapshot, the WMI database may contain the value saved at the moment the\nVM snapshot was created. If the snapshot was created a year ago, the\ncalculated system uptime will be a year as well even if a sandbox\nupdates the last boot time.\n\nThis fact can be used to detect a virtual machine restored from a\nsnapshot. Also, any anomalies in the last boot time can be used as\nsandbox indicators:\n\n-   The system uptime is too big (months or even years)\n-   The system uptime is to small (less than several minutes)\n-   The last boot time obtained using [other\n    methods](timing.html#get-system-time) differs from the last boot\n    time obtained using WMI\n\n**Code sample (VB)**\n\n    strComputer = "."\n    Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")\n    Set colOperatingSystems = objWMIService.ExecQuery ("Select * from Win32_OperatingSystem")\n     \n    For Each objOS in colOperatingSystems\n        dtmBootup = objOS.LastBootUpTime\n        dtmLastBootUpTime = WMIDateStringToDate(dtmBootup)\n        dtmSystemUptime = DateDiff("n", dtmLastBootUpTime, Now)\n        Wscript.Echo "System uptime minutes: " & dtmSystemUptime \n    Next\n     \n    Function WMIDateStringToDate(dtm)\n        WMIDateStringToDate =  CDate(Mid(dtm, 5, 2) & "/" & _\n            Mid(dtm, 7, 2) & "/" & Left(dtm, 4) & " " & Mid (dtm, 9, 2) & ":" & _\n            Mid(dtm, 11, 2) & ":" & Mid(dtm, 13, 2))\n    End Function\n\n*Code sample is taken from [Microsoft\nDocs](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-tasks--desktop-management)*\n\n\n**Signature recommendations**\n\nIf the following function is called with the 3rd argument\nBSTR("Win32\_OperatingSystem"):\n\n-   `IWbemServices_ExecQuery(..., BSTR("Win32_OperatingSystem"), ...)`\n\nthen it's a possible indicator of the application trying to use the\nevasion technique.\n\n**Countermeasures**\n\n-   Adjust the `KeBootTime` value\n-   Reset the WMI repository or restart the \"`winmgmt`\" service after\n    you adjust the `KeBootTime` value\n\n\n\\n\n### [4. Check the network adapters last reset time]{#check-network-adapter-reset-time .a-dummy}\n\nWe need to check if there are any adapters that were last reset a long\ntime ago. This may indicate the application is running in a virtual\nmachine restored from a snapshot.\n\n**Code sample (VB)**\n\n    strComputer = "."\n    Set objWMIService = GetObject("winmgmts:" & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")\n    Set colOperatingSystems = objWMIService.ExecQuery ("Select * from Win32_NetworkAdapter")\n     \n    For Each objOS in colNetworkAdapters\n        dtmLastReset = objOS.TimeOfLastReset\n        dtmLastResetTime = WMIDateStringToDate(dtmLastReset)  'WMIDateStringToDate function from the previous example\n        dtmAdapterUptime = DateDiff("n", dtmLastResetTime, Now)\n        Wscript.Echo "Adapter uptime minutes: " & dtmAdapterUptime \n    Next\n\n**Signature recommendations**\n\nIf the following function is called with the 3rd argument\nBSTR("Win32\_OperatingSystem"):\n\n-   `IWbemServices_ExecQuery(..., BSTR("Win32_NetworkAdapter"), ...)`\n\nthen it's a possible indicator of the application trying to use the\nevasion technique.\n\n**Countermeasures**\n\n-   Ensure an adequate last reset time for the network adapters\n-   Reset the WMI repository or restart the \"`winmgmt`\" service\n\n\\n\n### [Countermeasures]{#countermeasures .a-dummy}\n\nCountermeasures are presented in the appropriate sub-sections above.\n\n\\n\n### [Credits]{#credits .a-dummy}\n\n-   al-khaser project on\n    [GitHub](https://github.com/LordNoteworthy/al-khaser)\n-   Microsoft Docs - [WMI Tasks: Desktop\n    Management](https://docs.microsoft.com/en-us/windows/win32/wmisdk/)\n\n\\n\n::: {style="text-align: left"}\n[Go back](..)\n:::\n\n\\n\n::: {.sharebuttons style="text-align: center"}\n\n\n-   Share this:\n\n-   \n\n-   \n\n-   \n\n-   \n:::\n\n::: {.container .footer-content}\nMade with to serve the community by Check Point Research \| [Research\nblog](https://research.checkpoint.com){.a-pink} \| [About\nUs](https://research.checkpoint.com/about-us/){.a-pink} \|\n[](https://github.com/CheckPointSW){.a-pink}\n[](https://twitter.com/_CPResearch_){.a-pink}\\n© 1994-2024 Check Point Software Technologies LTD \| All rights reserved\n\| Property of CheckPoint.com\n:::\n